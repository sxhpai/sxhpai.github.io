[{"title":"力扣——数组","url":"/2022/04/28/2022-04-28-leetcode/","content":"数组2. 二分查找（22.4.27）704. 二分查找\n\n二分查找：注意区间的边界。\n\n3. 移除元素（22.4.28）力扣题目链接：\n27. 移除元素\n\n暴力破解：一个 for 循环遍历数组查找要移除的元素，另一个 for 循环更新数组。\n双指针法：通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。\n双指针法：双向指针，假如要删除的元素为 val ，从左边寻找等于 val 的元素，右边寻找不等于 val 的元素，将右边不等于 val 的元素覆盖到左边等于 val 的元素上。（__不等于的魅力__）\n\n4.  有序数组的平方（22.4.29）977. 有序数组的平方\n\n暴力破解：先都平方，再排个序，美滋滋。\n双指针：申请一个和原数组一样大的新数组空间，i 指向老数组的开头，j 指向老数组的结尾。k指向新数组的结尾。从大到小依次排序。\n\n5. 长度最小的子数组（22.4.30）209. 长度最小的子数组\n\n暴力求解\n滑动窗口\n\n76. 最小覆盖字串\n\n如何判断字符串 S 的字串包含了字符串 T 中的所有字符？\n这时我们需要统计：\nT 中所有字符种类和次数，生成一个字符频数数组\nS 中所有字符种类和次数，生成一个字符频数数组\n\n\n如果每个字符在 S 中出现的次数都大于等于在 T 中出现的次数，则说明 S 字符串包含了 T 中的所有字符。\n\n\n\n6. 螺旋矩阵II（22.5.4）螺旋矩阵II\n\n关键是找到旋转矩阵的规则\n考察对代码的掌控能力\n\n\n","categories":["C++","leetcode","数组"],"tags":["leetcode"]},{"title":"C++ 输入方式总结","url":"/2022/06/28/C++Cin/","content":"C++ 输入方式总结1.输入缓冲区程序的输入都有一个缓冲区，即输入缓冲区。每次输入过程当一次键盘输入结束时会将输入的数据存入输入缓冲区，而cin函数直接从输入缓冲区中取数据。正因为cin函数是直接从缓冲区取数据的，所以有时候当缓冲区中有残留数据时，cin函数会直接取得这些残留数据而不会请求键盘输入。\n例如：\nvoid input_test()&#123;\tstring str;\tcout&lt;&lt;&quot;cin的缓冲区测试：&quot;&lt;&lt;endl;\tcin&gt;&gt;str;\tcout&lt;&lt;str&lt;&lt;endl;\tcin&gt;&gt;str;\tcout&lt;&lt;str&lt;&lt;endl;&#125;\n\n测试结果如下：\ncin的缓冲区测试:a b c dab\n\n由于 cin遇到空格时就会停止输入，所以如果在第一次输入时，利用空格隔开两个字符串，那么 cin在第一次取的时候，只会读取前一个字符串，到空格结束，此时缓冲区还保留着前面输入的第二个字符串，因此第二次 cin就会直接从缓冲区取残留数据，而不会请求输入。\n如果要解决这个问题，可以在第二次调用 cin&gt;&gt;str 之前通过cin.sync()来清空输入缓冲区，代码如下:\nvoid input_test()&#123;\tstring str;\tcout&lt;&lt;&quot;cin的缓冲区测试：&quot;&lt;&lt;endl;\tcin&gt;&gt;str;\tcin.sync();\tcout&lt;&lt;str&lt;&lt;endl;\tcin&gt;&gt;str;\tcout&lt;&lt;str&lt;&lt;endl;&#125;\n\n2. cin&gt;&gt;当 cin&gt;&gt;从缓冲区中读取数据时，若缓冲区中第一个字符是 [enter],[space],[tab]这些结束符时，cin&gt;&gt;会将其忽略并清除，继续读取下一个字符。如果不想略过空白字符，可以使用 noskipws流控制：cin&gt;&gt;noskipws&gt;&gt;inputs[j];\ncin&gt;&gt;以 Space、Tab、Enter作为结束符，但结束符会残留在缓冲区，cin&gt;&gt;不做处理。\n3. cin.get()cin.get()有多种重载形式，分为四种格式：无参，一参数，二参数，三参数。\nint cin.get();istream&amp; cin.get(char&amp; var);istream&amp; get (char* s, streamsize n);istream&amp; get (char* s, streamsize n, char delim);\n\n用法1. a &#x3D; cin.get() 或 cin.get(a)功能：接收一个字符，把它的 ASCLL 码存入到&#96;&#96; a 中，以回车键结束，并且 [enter],[space],[tab]也会被读取。\n用法2. cin.get(arrayname,size)功能：**arrayname必须是 char* 类型，即 char 类型数组，不可以为 string 类型；size 是指输入长度，即允许输入的最大长度，函数只能读取前 size - 1个数据，最后一个补 &#39;\\0&#39;。**\nvoid inputest() &#123;    char ch[3];    cin.get(ch,3);    cout &lt;&lt; ch &lt;&lt; endl;&#125;\n\n结果如下：\nasdfas\n\n输入 asdf，cin.get(a,3); 只能接收前两个数据 as，最后一个补 &#39;\\0&#39;。\n用法3. cin.get(arrayname,size,s)功能：cin.get(arrayname,size,s) 把数据输入到arrayname字符数组中，当到达长度size时结束或者遇到字符s时结束。\n注意：s为结束符，遇到s则当前输入结束，但是s不会被清除，仍然保留在缓冲区里。\n4.cin.getline()cin.getline()从标准输入设备键盘读取一行字符串，并以指定的结束符结束。\n函数原型有两个：\nistream&amp; getline(char* s, streamsize count); // 默认以换行符结束istream&amp; getline(char* s, streamsize count, char delim); // 以指定的结束符结束\n\ncin.getline()的用法和cin.get()用法大致相同，区别主要有以下两点：\n\ncin.getline()遇到结束符时，会将结束符一并读入指定的char数组中，再将结束符替换为空字符。因此，cin.getline()不会将结束符残留在输入缓冲区。\n\ncin.get()当输入的字符串超长时，不会引起cin函数的错误，后面若有cin操作，会继续执行，只是直接从缓冲区中取数据；但是当cin.getline()输入超过指定长度时，会引起cin函数的错误，后面的cin操作将不再执行。使用 cin.clear() 即可恢复。\n\n\n5. getline()C++中定义了一个在std名字空间的全局函数getline()，不同于前面所提到的cin，cin.get()，cin.getline() ，getline()在string库函数下，而非前面的 istream 流，所以调用前要在前面加入#include&lt; string&gt;。\n函数原型有两个重载形式：\nistream&amp; getline ( istream&amp; is, string&amp; str); // 默认以换行符结束istream&amp; getline ( istream&amp; is, string&amp; str, char delim);  // 以指定的结束符结束\n\ngetline()第二个参数为string类型，而不再是char*，要注意区别。另外，该方法也不是遇到空格就结束输入的。\n注意1：与cin.getline()类似，getline()遇到结束符时，会将结束符一并读入指定的string中，再将结束符替换为空字符，因此getline()也不会将结束符留在缓冲区。因此，进行从键盘读取一行字符时，建议使用getline，较为安全。但是，最好还是要进行标准输入的安全检查，提高程序容错能力。注意2：cin.getline() 与 getline() 在以指定字符作为分隔符时，遇到换行符照样会读取，而不会结束。\n","categories":["C++"],"tags":["C++"]},{"title":"AI","url":"/2022/07/01/AI/","content":"命令汇总pip list #当前环境下的安装包情况nvidia-smi\t#查看显卡信息# 检测torch是否安装成功，以及GPU是否可以被torch使用# 进入python环境import pythontorch.cuda.is_available()#删除镜像conda config --remove channels \n\npython三种编辑器比较\npython 文件，以整体为一块运行（pycharm中的 .py 文件）\n优点：通用，传播方便，适用于大型项目\n缺点：需要从头运行\n\n\npython 控制台，以一行为一块运行，或任意行为一块运行\n优点：显示每个变量属性\n缺点：不利于代码阅读及修改\n\n\npython jupyter，以任意行为一块运行\n优点：利于代码阅读及修改\n缺点：环境需要配置\n\n\n\n文件配置\nDataset:\t提供一种方式去获取数据及其label\n如何获取每一个数据机器label\n告诉我们总共有多少数据\n\n\nDataloader:    为后面的网络提供不同的数据形式\n\n","categories":["Python"],"tags":["Pytorch"]},{"title":"大厂入职规划","url":"/2022/05/01/Fall%20Recruit/","content":"秋招时间节点\n如果你是 23 届，其实 22 年 9 月份开始秋招。\n\n先了解校招时间节点，对于 23 届毕业生是这样的：\n\n2022 年 3 月份左右就开始暑期实习招聘了，如果相冲大厂暑期实习，那么应该在 2021年就开始认真准备。\n\n2022 年 7 月，秋招提前批 在 7月份左右就开始了，现在提前批和校招越来越早。\n\n2022 年 8 月，秋招正式开始\n\n2022 年 9 月开始全面秋招，各大招聘信息已经铺天盖地。\n\n2022 年 11 月 12 月份会有 补招。\n\n2023 年 3月还会有春季招聘，也是面对2023届毕业生。 不过春季招聘岗位比较少，不到位不得己，不要拖到春季校招。\n\n\nSXHPAI时间规划22年 5 月初 - 6月末：（2个月）\n代码随想录 一刷\n《C++ Primer》一刷\n《Effective C++》《Effective STL》《STL源码剖析》《深度探索 C++ 对象模型》\n\n22年 7月初 - 23年 1月末（5个月）\n计算机基础（这些书粗略看一遍就行，不要沉迷进去，就开始刷面经，然后面经哪里不会看哪里。）\n操作系统：《操作系统导论》《深入理解操作系统》（这本书把计算机组成原理也包含了）\n计算机网络：《网络是怎样连接的》《图解HTTP》《图解TCP&#x2F;IP》《计算机网络自顶向下》\n数据库：《MySQL必知必会》《从根上理解mysql》《MySql实战45讲》\nlinux：《Linux高性能服务器编程》《Unix网络编程》\n设计模式：《大话设计模式》\n\n\n项目：\n字节写一套STL，学习STL的同时，可以实现一套自己的 mini STL。如这个MyTinySTL\nweb server：烂大街的网络编程项目。如这个TinyWebServer\n\n\n\n23年 2月初 - 23年 5月末（key 4个月）\n刷爆 代码随想录\n刷爆 面试八股文\n实习招聘 3月份左右\n\n23年 6月初 - 7月末\n提前批\n\n23年 8月初 - 9月末\n秋招正式批\n\n23年 11月 - 12月\n秋招补录\n\n24年 3月\n春招\n\n","tags":["规划"]},{"title":"数据结构——查找","url":"/2022/04/15/DS6/","content":"开场\n查找就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。\n\n查找概论\n查找表：由同一类型的数据元素（或记录）构成的集合。\n\n关键字（Key）是数据元素中某个数据项的值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项，我们称为关键码。\n\n若此关键字可以唯一地标识一个记录，则称关键字为__主关键字__。\n\n对于那些可以识别多个数据元素（或记录）的关键字，我们称为次关键字。\n\n\n\n查找表按照操作方式来分有两种：静态查找表和动态查找表\n\n静态查找表：只作查找操作的查找表，它的主要操作有：\n查询某个”特定的“数据元素是否在查找表中。\n检索某个”特定的“数据元素和各种属性。\n\n\n动态查找表：在查找过程中，同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。显然动态查找表的操作就是两个：\n查找时插入数据元素。\n查找时删除数据元素。\n\n\n\n\n\n为了查找的效率，我们需要专门为查找操作设置数据结构，这种面向查找操作的数据结构称为查找结构。\n\n顺序表查找顺序查找又叫线性查找，是基本的查找技术，它的查找过程是：从表中的第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。\n\n顺序查找算法（ O(n) ）\n顺序查找优化（放置哨兵，提高查找效率）（ O(n) ）\n\n有序表查找\n折半查找\t（O( logn )）\n\n折半查找，又称二分查找。它的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。折半查找的基本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间的关键字相等，则查找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续查找；若给定值大于中间记录的关键字，则在中间记录的右半区继续查找。不断重复上述过程，直到查找成功，或所有查找区域无记录，查找失败为止。\n\n折半查找，不适合需要频繁执行插入或删除操作的数据集。因为维护有序的排序会带来不小的工作量。\n\n\n//二分查找//a为数组，n为n要查找的数组有效长度（从a[1]开始到a[n]结束的长度），key为要查询的关键字/******************* 时间复杂度: O(logn)****************/int Binary_Search(int *a, int n, int key) &#123;    int low,high,mid;    low = 1;            //定义最低下标为记录首位    high = n;           //定义最高下标为记录末位    while(low &lt;= high) &#123;        mid = (low + high)/2;   //二分        if (key &lt; a[mid]) &#123;     //若查找值比中值小            high = mid - 1;     //最高下标调整到中位下标小一位        &#125;else if (key &gt; a[mid]) &#123;  //若查找值比中值大            low = mid + 1;      //最低下标调整到中位下标大一位        &#125;else &#123;            return mid;         //若相等则说明 mid 即为查找到的位置        &#125;    &#125;    return 0;&#125;\n\n\n\n插值查找（O( logn )）\n\n**插值公式${key - a[low]}\\over{a[high] - a[low]}$**，二分查找的优化。\n\n//插值查找，二分查找的优化//a为数组，n为n要查找的数组有效长度（从a[1]开始到a[n]结束的长度），key为要查询的关键字/******************* 时间复杂度: O(logn)****************/int Interpolation_Search(int *a, int n, int key)&#123;    int low, high, mid;    low = 1;    high = n;    while( low &lt;= high ) &#123;        // mid = (low + high)/2;        mid = low + (high - low)*(key - a[low])/(a[high] - a[low]);/**** 插值公式****/                if(key &lt; a[mid]) &#123;            high = mid - 1;        &#125;else if (key &gt; a[mid]) &#123;            low = mid + 1;        &#125;else &#123;            return mid;        &#125;    &#125;    return 0;&#125;\n\n斐波那契查找（O(logn)）\n\n斐波那契查找的核心是：\n\n\n\n当 key &#x3D; a[mid] 时，查找就成功；\n当 key &lt; a[mid] 时，新范围是第 low 个到第 mid-1 个，此时范围个数为 F[k-1]-1 个；\n当 key &gt; a[mid] 时，新范围是第 mid+1 个到第 high 个，此时范围个数为 F[k-2]-1 个。\n\n\n//斐波那契查找，二分查找的优化//a为数组，n为n要查找的数组有效长度（从a[1]开始到a[n]结束的长度），key为要查询的关键字/******************* 时间复杂度: O(logn)****************/int F[] = &#123;0,1,1,2,3,5,8,13,21,34,55,89&#125;;   //定义一个斐波那契数列int Fibonacci_Search(int *a, int n, int key) &#123;    int low, high, mid, i, k;    low = 1;                        //定义最低下标为记录首位    high = n;                       //定义最高下标为记录末位    k = 0;                      while (n &gt; F[k] - 1) &#123;          //计算 n 位于斐波那契数列的位置        k++;    &#125;    for ( i = n; i &lt; F[k] - 1; i++) &#123;   //将不满的数值补全        a[i] = a[n];    &#125;    //查询    while(low &lt;= high) &#123;        mid = low + F[k - 1] - 1;       //计算当前分隔的下标        if (key &lt; a[mid]) &#123;            high = mid - 1;     //最高下标调整到分隔下标 mid-1 处            k = k - 1;          //斐波那契数列下标减一位        &#125;else if (key &gt; a[mid]) &#123;            low = mid + 1;      //最低位下标调整到分隔下 mid=1 处            k = k - 2;          //斐波那契数列下标减两位        &#125;else &#123;            if (mid &lt;= n) &#123;                return mid;     //若相等则说明 mid 即为查找到的位置            &#125;else &#123;                return n;       //若 mid&gt;n 说明是补全数值，返回 n            &#125;        &#125;    &#125;    return 0;&#125;\n\n三种有序表查找本质上是分隔点的选择不同，各有优劣。\n\n\n线性索引查找\n数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的一种数据结构。索引就是把一个关键字与它对应的记录相关联的过程。\n\n索引按照结构可以分为线性索引、树状索引和多级索引。这里只有线性索引。\n\n线性索引介绍三种：稠密索引、分块索引、倒排索引。\n\n\n\n\n稠密索引：对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。\n分块索引：分块有序，是把数据集的记录分成了若干块，并且这些块需要满足块内无序、块间有序。对于分块有序的数据集，将每块对应一个索引项，这种方法叫分块索引。\n倒排索引：搜索引擎的基础。\n\n\n二叉排序树\n二叉排序树，又称为二叉查找树。他或者是一棵空树，或者是具有下列性质的二叉树。\n\n若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值；\n若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n它的左右二叉树也分别为而二叉排序树。\n\n\n构造一棵二叉排序树的目的，并不是为了排序，而是为了提高查找和插入删除关键字的速度。\n/*递归查找二叉排序树 T 中是否存在 key*//*指针f指向 T 的双亲，其初始调用值为 NULL ，递归调用时有用*//*若查找成功，则指针 p 指向该数据元素结点， 并返回 TRUE *//*否则指针 p 指向查找路径上访问的最后一个结点并返回 FALSE */Status SearchBST(BiTree T, int key, BiTree f, BiTree *p)&#123;    if (!T) &#123;                           //查找不成功        *p = f;        return FALSE;    &#125;    else if (key == T-&gt;data) &#123;          //查找成功        *p = T;        return TRUE;    &#125;else if (key &lt; T-&gt;data) &#123;        SearchBST(T-&gt;lchild, key, T, p);//在左子树继续查找    &#125;else &#123;        SearchBST(T-&gt;rchild, key, T, p);//在右子树继续查找    &#125;&#125;\n\n平衡二叉树\n平衡二叉树，是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于1。\n我们将二叉树上结点的左子树深度减去右子树深度的值称为平衡因子 BF ，那么平衡二叉树上所有结点的平衡因子只可能是 -1，0，1。只要二叉树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。\n距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，我们称为最小不平衡树。\n\n\n\n平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点时，先检查是否因插入而破坏了树的平衡，若是，则找出最小不平衡树。在保持二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。\n\n所谓平衡二叉树，其实就是二叉排序树创建过程中保证它的平衡性，一旦发现不平衡的情况，马上处理，就这样不会造成不可收拾的情况出现。\n\n\n\n\n如果我们需要查找的集合本身没有顺序，在频繁查找的同时也需要经常的插入和删除操作，显然我们需要构建一棵二叉排序树，但是不平衡的二叉排序树，查找效率是非常低的，因此我们需要在构建时，就让这棵二叉排序树是平衡二叉树，此时我们的查找时间复杂度为 O(logn)，而插入和删除也为 O(logn)，这显然是比较理想的一种动态查找表算法。\n\n平衡二叉树算法\n右旋处理\n/* 对以p为根的二叉排序树作右旋处理， *//* 处理之后p指向新的树根结点，即旋转处理之前的左子树的根结点 */void R_Rotate(BiTree *P)&#123; //如下图\tBiTree L;\tL=(*P)-&gt;lchild; \t\t/* L指向P的左子树根结点 */ \t(*P)-&gt;lchild=L-&gt;rchild; /* L的右子树挂接为P的左子树 */ \tL-&gt;rchild=(*P);\t\t\t/* P连接为L的右子树 */\t*P=L; \t\t\t\t\t/*  P指向新的根结点 */ &#125;\n\n\n\n左旋处理\n/* 对以P为根的二叉排序树作左旋处理， *//* 处理之后P指向新的树根结点，即旋转处理之前的右子树的根结点0  */void L_Rotate(BiTree *P)&#123; //如下图\tBiTree R;\tR=(*P)-&gt;rchild; \t\t/* R指向P的右子树根结点 */ \t(*P)-&gt;rchild=R-&gt;lchild; /* R的左子树挂接为P的右子树 */ \tR-&gt;lchild=(*P);\t\t\t/* P连接为R的左子树*/\t*P=R; \t\t\t\t\t/* P指向新的根结点 */ &#125;\n\n\n\n左平衡处理代码\n#define LH +1 /*  左高 */ #define EH 0  /*  等高 */ #define RH -1 /*  右高 */ /*  对以指针T所指结点为根的二叉树作左平衡旋转处理 *//*  本算法结束时，指针T指向新的根结点 */void LeftBalance(BiTree *T)&#123; \tBiTree L,Lr;\tL=(*T)-&gt;lchild; /*  L指向T的左子树根结点 */ \tswitch(L-&gt;bf)\t&#123; /*  检查T的左子树的平衡度，并作相应平衡处理 */ \t\t case LH: /*  新结点插入在T的左孩子的左子树上，要作单右旋处理 */ \t\t\t(*T)-&gt;bf=L-&gt;bf=EH;\t\t\tR_Rotate(T);\t\t\tbreak;\t\t case RH: /*  新结点插入在T的左孩子的右子树上，要作双旋处理 */ \t\t\tLr=L-&gt;rchild; /*  Lr指向T的左孩子的右子树根 */ \t\t\tswitch(Lr-&gt;bf)\t\t\t&#123; /*  修改T及其左孩子的平衡因子 */ \t\t\t\tcase LH: (*T)-&gt;bf=RH;\t\t\t\t\t\t L-&gt;bf=EH;\t\t\t\t\t\t break;\t\t\t\tcase EH: (*T)-&gt;bf=L-&gt;bf=EH;\t\t\t\t\t\t break;\t\t\t\tcase RH: (*T)-&gt;bf=EH;\t\t\t\t\t\t L-&gt;bf=LH;\t\t\t\t\t\t break;\t\t\t&#125;\t\t\tLr-&gt;bf=EH;\t\t\tL_Rotate(&amp;(*T)-&gt;lchild); /*  对T的左子树作左旋平衡处理 */ \t\t\tR_Rotate(T); /*  对T作右旋平衡处理 */ \t&#125;&#125;\n\n\n\n右平衡处理代码\n#define LH +1 /*  左高 */ #define EH 0  /*  等高 */ #define RH -1 /*  右高 */ /*  对以指针T所指结点为根的二叉树作右平衡旋转处理， */ /*  本算法结束时，指针T指向新的根结点 */ void RightBalance(BiTree *T)&#123; \tBiTree R,Rl;\tR=(*T)-&gt;rchild; /*  R指向T的右子树根结点 */ \tswitch(R-&gt;bf)\t&#123; /*  检查T的右子树的平衡度，并作相应平衡处理 */ \t case RH: /*  新结点插入在T的右孩子的右子树上，要作单左旋处理 */ \t\t\t  (*T)-&gt;bf=R-&gt;bf=EH;\t\t\t  L_Rotate(T);\t\t\t  break;\t case LH: /*  新结点插入在T的右孩子的左子树上，要作双旋处理 */ \t\t\t  Rl=R-&gt;lchild; /*  Rl指向T的右孩子的左子树根 */ \t\t\t  switch(Rl-&gt;bf)\t\t\t  &#123; /*  修改T及其右孩子的平衡因子 */ \t\t\t\tcase RH: (*T)-&gt;bf=LH;\t\t\t\t\t\t R-&gt;bf=EH;\t\t\t\t\t\t break;\t\t\t\tcase EH: (*T)-&gt;bf=R-&gt;bf=EH;\t\t\t\t\t\t break;\t\t\t\tcase LH: (*T)-&gt;bf=EH;\t\t\t\t\t\t R-&gt;bf=RH;\t\t\t\t\t\t break;\t\t\t  &#125;\t\t\t  Rl-&gt;bf=EH;\t\t\t  R_Rotate(&amp;(*T)-&gt;rchild); /*  对T的右子树作右旋平衡处理 */ \t\t\t  L_Rotate(T); /*  对T作左旋平衡处理 */ \t&#125;&#125;\n\n\n平衡二叉树生成代码主函数\n/*  若在平衡的二叉排序树T中不存在和e有相同关键字的结点，则插入一个 */ /*  数据元素为e的新结点，并返回1，否则返回0。若因插入而使二叉排序树 */ /*  失去平衡，则作平衡旋转处理，布尔变量taller反映T长高与否。 */Status InsertAVL(BiTree *T,int e,Status *taller)&#123;  \tif(!*T)\t&#123; /*  插入新结点，树“长高”，置taller为TRUE */ \t\t *T=(BiTree)malloc(sizeof(BiTNode));\t\t (*T)-&gt;data=e; (*T)-&gt;lchild=(*T)-&gt;rchild=NULL; (*T)-&gt;bf=EH;\t\t *taller=TRUE;\t&#125;\telse\t&#123;\t\tif (e==(*T)-&gt;data)\t\t&#123; /*  树中已存在和e有相同关键字的结点则不再插入 */ \t\t\t*taller=FALSE; return FALSE;\t\t&#125;\t\tif (e&lt;(*T)-&gt;data)\t\t&#123; /*  应继续在T的左子树中进行搜索 */ \t\t\tif(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller)) /*  未插入 */ \t\t\t\treturn FALSE;\t\t\tif(*taller) /*   已插入到T的左子树中且左子树“长高” */ \t\t\t\tswitch((*T)-&gt;bf) /*  检查T的平衡度 */ \t\t\t\t&#123;\t\t\t\t\tcase LH: /*  原本左子树比右子树高，需要作左平衡处理 */ \t\t\t\t\t\t\tLeftBalance(T);\t*taller=FALSE; break;\t\t\t\t\tcase EH: /*  原本左、右子树等高，现因左子树增高而使树增高 */ \t\t\t\t\t\t\t(*T)-&gt;bf=LH; *taller=TRUE; break;\t\t\t\t\tcase RH: /*  原本右子树比左子树高，现左、右子树等高 */  \t\t\t\t\t\t\t(*T)-&gt;bf=EH; *taller=FALSE; break;\t\t\t\t&#125;\t\t&#125;\t\telse\t\t&#123; /*  应继续在T的右子树中进行搜索 */ \t\t\tif(!InsertAVL(&amp;(*T)-&gt;rchild,e,taller)) /*  未插入 */ \t\t\t\treturn FALSE;\t\t\tif(*taller) /*  已插入到T的右子树且右子树“长高” */ \t\t\t\tswitch((*T)-&gt;bf) /*  检查T的平衡度 */ \t\t\t\t&#123;\t\t\t\t\tcase LH: /*  原本左子树比右子树高，现左、右子树等高 */ \t\t\t\t\t\t\t(*T)-&gt;bf=EH; *taller=FALSE;\tbreak;\t\t\t\t\tcase EH: /*  原本左、右子树等高，现因右子树增高而使树增高  */\t\t\t\t\t\t\t(*T)-&gt;bf=RH; *taller=TRUE; break;\t\t\t\t\tcase RH: /*  原本右子树比左子树高，需要作右平衡处理 */ \t\t\t\t\t\t\tRightBalance(T); *taller=FALSE; break;\t\t\t\t&#125;\t\t&#125;\t&#125;\treturn TRUE;&#125;\n\n二叉平衡树源代码\n\n\n多路查找树（B树）多路查找树，其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。\n2-3树\n2-3树是这样的一棵多路查找树：其中的每一个结点都具有两个孩子（我们称它为2结点）或三个孩子（我们称它为3结点）。\n\n一个2结点包含一个元素和两个孩子（或没有孩子），且与二叉排序树类似，左子树包含的元素小于该元素，右子树包含的元素大于该元素。不过，与二叉排序树不同的是，这个2结点要么没有孩子，要有就有两，不能只有一个孩子。\n\n一个3结点包含一小一大两个元素和三个孩子（或没有孩子），一个3结点要么没有孩子，要么具有3个孩子。如果某个3结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。\n\n\n2-3-4树\n2-3-4树就是2-3树的概念扩展，包括了4结点的使用。一个4结点包含小、中、大三个元素和四个孩子（或没有孩子），一个4结点要么没有孩子，要么具有4个孩子。如果某个4结点有孩子的话，左子树包含小于最小元素的元素；第二个子树包含大于最小元素，小于第二元素的元素；第三子树包含大于第二元素，小于最大元素的的元素；右子树包含大于最大元素的元素。\n\nB树\n\nB树，是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例。结点最大的孩子数目称为B树的阶。因此，2-3树是3阶B树，2-3-4树是4阶B树。\n\n一个 m 阶的 B 树具有如下属性：\n\n如果根结点不是叶子结点，则其至少有两棵子树。\n每一个非根的分支结点都有$k-1$个元素和$k$个孩子，其中$⌈m&#x2F;2⌉ \\leq k \\leq m$。 每一个叶子结点$n$都有$k-1$个元素，其中$⌈m&#x2F;2⌉ \\leq k \\leq m$。\n所有叶子结点都位于同一层次。\n所有分支结点包含下列信息数据$(n,A_0,K_1,A_1,K_2,A_2,…,K_n,A_n)$，其中：$K_i(i &#x3D; 1,2,…,n)$为关键字，且$K_i&lt;K_{i-1}(i &#x3D; 1,2,…,n-1)$；$A_i(i &#x3D; 0,1,2,…,n)$为指向子树根结点的指针，且指针$A_{i-1}$所指子树中所有结点的关键字均大于$K_n$，$ n (⌈m&#x2F;2⌉-1 \\leq n \\leq m-1) $为关键字的个数（或$n+1$为子树的个数）。\n\n\n\n可以说，__B 树__的数据结构就是为 内外存 的数据交互准备的。\n\n再含有$n$个关键字的 B 树上查找时，从根结点到关键字结点的路径上涉及的结点数不超过$log_{\\frac{⌈m⌉}{2}} \\left( \\frac{n+1}{2}\\right)+1$。\n\n\nB+树\n\nB+树是应文件系统所需而出的一种B树的变形树，注意严格意义上讲，它其实已经不是第六章定义的树了。\n\n在B树中，出现在分支结点中的元素会被当做它们在该分支结点位置的中序后继者（叶子结点）中再次列出。另外，每一个叶子结点都会保存一个指向后一叶子结点的指针。\n\n一棵 m 阶 B+ 树和 m 阶的 B 树的差异在于：\n\n有 n 棵子树的结点中包含 n 个关键字。\n所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小而大顺序链接。\n所有分支结点可以看成索引，结点中仅含有其子树中的最大（或最小）关键字。\n\n\n\nB+ 树的结构特别适合带有范围的查找。\n\nB+ 树的插入、删除过程也都有与 B 树类似，只不过插入和删除的元素都是在叶子结点上进行而已。\n\n\n散列查找（哈希表）概述\n\n    \n        存储位置 = f(关键字)\n    \n\n\n散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f ，使得每个关键字 key 对应一个存储位置 f (key)。\n\n查找时根据这个确定的对应关系找到给定值 key 的映射 f(key)，若查找集合中存在这个记录，则必定在 f(key)的位置上。\n我们把这种对应关系 f 称为散列函数，又称为哈希（Hash）函数。按照这种思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表（Hash Table）。关键字对应的记录存储位置我们称为散列地址。\n散列技术既是一种存储方法，也是一种查找方法。\n散列主要是面向查找的存储结构\n__散列技术最合适的求解问题是查找与给定值相等的记录__。\n理想情况下，每一个关键字，通过散列函数计算出来的地址都是不一样的，可现实中，这只是一个理想。我们经常碰到，两个关键字 key1≠key2，但是却有 f(key1) &#x3D; f(key2)，这种现象我们称为冲突，并把 key1和key2称为这个散列函数的同义词。\n\n\n散列函数的构造方法\n散列函数设计的两个原则：\n\n计算简单，散列函数的计算时间不应该超过其他查找技术与关键字比较的时间。\n散列地址分布均匀，冲突带来的问题，最好的办法就是尽量让散列地址均匀地分布在存储空间中，这样可以保证存储空间的有效利用，并减少为处理冲突而耗费的时间。\n\n\n“间谍们”设计的散列函数（这些方法都是将原来数字按某种规律变成另一个数字而已。）\n\n直接定址法\n\nf(key) = a × key + b （a、b为常数）\n\n取关键字的某个线性函数值为散列地址。\n\n优点：简单、均匀，也不会产生冲突，但问题是这__需要知道关键字的分布情况__，适合查找表较小且连续的情况。并不常用。\n\n数字分析法\n抽取的方法是使用关键字的一部分来计算散列存储位置的方法，这在散列函数中是常常用到的手段。\n数字分析法通常适合处理关键字位数比较大的情况，如果__事先知道关键字的分布且关键字的若干位分布较均匀__，就可以考虑用这个方法。\n\n平方取中法\n平方取中法比较适合于__不知道关键字的分布__，而位数又不是很大的情况。\n\n折叠法\n折叠法__事先不需要知道关键字的分布__，适合关键字位数较多的情况。\n\n除留余数法\n\nf(key) = key mod p ( p ≤ m )\n\nmod 取模（求余数）的意思。\n\n根据前辈的经验，若散列表表长为 m，通常 p 为小于或等于表长（最好接近 m ）的最小质数或不包含小于 20 质因子的合数。\n\n随机数法\n\n f(key) = random(key)\n\n选择一个随机数，取关键字的随机函数值为它的散列地址。当__关键字长度不等时__，采用这个方法构造散列函数是比较合适的。\n\n散列函数选取时，应当考虑的一些因素\n\n计算散列地址所需的时间\n关键字的长度\n散列表的大小\n关键字的分布情况\n记录查找的频率\n\n综合这些因素，才能决策选择哪种散列函数最合适。\n\n\n\n\n处理散列冲突的方法\n开放定址法\n\n所谓开放地址法，就是一旦发生了冲突，就去寻找下一空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。\n  &gt; &lt;center&gt;f&lt;sub&gt;i&lt;/sub&gt; (key) = ( f (key) + d&lt;sub&gt;i&lt;/sub&gt;) MOD m &amp;nbsp;&amp;nbsp; (d&lt;sub&gt;i&lt;/sub&gt; = 1,2,3,……,m-1) &lt;/center&gt;\n  &gt;\n  &gt; 这种解决冲突的开放定址法称为线性探测法。\n  \n  &gt; &lt;center&gt; f&lt;sub&gt;i&lt;/sub&gt; ( key ) = ( f ( key ) + d&lt;sub&gt;i&lt;/sub&gt; ) MOD m &amp;nbsp; (d&lt;sub&gt;i&lt;/sub&gt; = 1&lt;sup&gt;2&lt;/sup&gt;,-1&lt;sup&gt;2&lt;/sup&gt;,2&lt;sup&gt;2&lt;/sup&gt;,-2&lt;sup&gt;2&lt;/sup&gt;,3&lt;sup&gt;2&lt;/sup&gt;,-3&lt;sup&gt;2&lt;/sup&gt;,……,q&lt;sup&gt;2&lt;/sup&gt;,-q&lt;sup&gt;2&lt;/sup&gt;,(m-1)&lt;sup&gt;2&lt;/sup&gt; )&lt;/center&gt;\n  &gt;\n  &gt; 这种方法我们称为二次探测法。\n  \n  &gt; 还有一种方法，对于位移量$d_i$采用随机函数计算得到，我们称之为随机探测法。\n\n\n总之，开放地址法只要再散列表未填满时，总是能找到不发生冲突的地址，是我们常用的解决冲突的办法。\n\n\n\n再散列函数法\n\n准备多个散列函数，一个发生冲突就换一个，相信总有一个可以把冲突解决掉。\n\n这种方法能够使得关键字不产生聚集，当然，相应地也增加了计算的时间。\n\n\n\n链地址法\n\n将所有关键字为同义词的记录存储再一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。\n\n链地址法对于可能造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保障。当然，这也就带来了查找时需要遍历单链表的性能损耗。\n\n\n\n公共溢出区法\n\n我们为所有冲突的关键字建立了一个公共的溢出区来存放。\n在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表去进行顺序查找。\n如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。\n\n\n\n散列表查找实现散列表查找算法的实现#define SUCCESS 1#define UNSUCCESS 0#define HASHSIZE 12      //定义散列表长为数组的长度#define NULLKEY -32768#define OK 1#define ERROR 0typedef int Status;typedef struct &#123;    int *elem;      //数据元素存储基址，动态分配数组    int count;      //当前数据元素个数&#125;HashTable;int m = 0;      //散列表表长，全局变量/* 初始化散列表 */Status InitHashTable( HashTable *H)&#123;    int i;    m = HASHSIZE;    H-&gt;count = m;    H-&gt;elem = ( int * )malloc( m * sizeof( int ) ); //申请 m 个int 那么大的存储空间    for( i = 0; i &lt; m; i++ ) &#123;        H-&gt;elem[i] = NULLKEY;       //将所有的元素初始化为NULLKEY    &#125;    return OK;&#125;/* 散列函数 */int Hash(int key)&#123;    return key % m; //除留余数法&#125;/* 插入关键字进散列表 */void InsertHash( HashTable *H, int key)&#123;    int addr = Hash(key);    while( H-&gt;elem[addr] != NULLKEY) &#123;   // 如果不为空，则冲突        addr = (addr + 1) % m;          // 开放定址法的线性探测    &#125;        H-&gt;elem[addr] = key;                // 直到有空位后插入关键字&#125;/* 散列表查找关键字 */Status SearchHash( HashTable H, int key, int *addr)&#123;    *addr = Hash(key);                  //求散列地址，关键    while(H.elem[*addr] != key) &#123;       //若关键字与取得地址上的关键字不同，说明有冲突        *addr = (*addr + 1) % m;        //开放地址法线性探测        if ( H.elem[*addr] == NULLKEY || *addr == Hash(key) ) &#123;            //如果循环回到原点            return UNSUCCESS;        &#125;    &#125;    return SUCCESS;&#125;\n\n\n\n散列表查找性能分析\n如果没有冲突，散列查找是我们本章介绍的所有查找中效率最高的，因为它的时间复杂度为 O(1)。\n散列表的平均查找长度取决于以下因素：\n散列函数是否均匀，散列函数的好坏直接影响着出现冲突的频繁程度。不过，由于不同的散列函数对同一组随机的关键字，产生冲突的可能性是相同的，因此我们可以不考虑它对平均查找长度的影响。\n处理冲突的方法。相同的关键字、相同的散列函数，但处理冲突的方法不同，会使得平均查找长度不同。比如线性探测处理冲突可能会产生冲堆积，显然就没有二次探测好，而链地址法处理冲突不会产生任何堆积，因而具有更佳的平均查找性能。\n散列表的装填因子。所谓装填因子  a &#x3D; 填入表中的记录个数 &#x2F; 散列表长度。a 标志着散列表的装满的程度。当填入表中的记录越多，a就越大，产生冲突的可能性就越大。也就是说，散列表的平均查找长度取决于装填因子，而不是取决于查找集合中的记录个数。\n\n\n不管记录个数  n 有多大，我们总可以选择一个合适的装填因子以便将平均查找长度限定在一个范围之内，此时我们散列查找的时间复杂度就真的是 O(1)了。为了做到这一点，通常我们都是将散列表的空间设置得比查找集合大，此时虽然浪费了一定的空间，但换来的是查找相连的大大提升，总的来时，非常值得。\n\n","categories":["C","数据结构"],"tags":["DS笔记"]},{"title":"数据结构——排序","url":"/2022/04/22/DS7/","content":"排序概论\n排序的稳定性\n\n内排序与外排序\n内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。\n\n时间性能\n时间效率搞的内排序算法应该是具有尽可能少的关键字比较次数和尽可能少的记录移动次数。\n\n辅助空间\n辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。\n\n算法的复杂性\n\n\n\n根据排序过程中借助的主要操作，我们把内排序分为：插入排序、交换排序、选择排序和归并排序\n\n本章按照算法的复杂度，分为两大类，冒泡排序、简单选择排序和直接插入排序属于简单算法；而希尔排序、堆排序、归并排序、快速排序属于改进算法。\n\n\n//程序公用部分#define TRUE 1#define FALSE 0#define MAXSIZE 10          // 用于要排序数组个数最大值，可根据需要修改typedef int Status;typedef struct &#123;    int r[MAXSIZE + 1];     // 用于存储要排序数组，r[0]用作哨兵或临时变量    int length;             // 用于记录顺序表长度&#125;SqList;/* 交换 L 中数组 r 的下标为 i 和 j 的值 */void swap(SqList *L, int i, int j)&#123;    int temp = L-&gt;r[i];    L-&gt;r[i] = L-&gt;r[j];    L-&gt;r[j] = temp;&#125;//顺序表初始化void InitSqList(SqList *L)&#123;    int i;    int temp[11] = &#123;0,20,10,70,40,60,50,30,90,80,100&#125;;    for( i = 1; i &lt;= 10; i++) &#123;        L-&gt;r[i] = temp[i];    &#125;    L-&gt;length = MAXSIZE;&#125;//打印顺序表void PrintSqList(SqList L)&#123;    int i;    for( i = 1; i&lt;=10; i++) &#123;        printf(&quot; %d&quot;,L.r[i]);    &#125;    printf(&quot;\\n&quot;);&#125;\n\n冒泡排序（$O(n^2)$）\n冒泡排序的思想就是不断的在交换，通过交换完成最终的排序。\n冒泡排序：一种交换排序，他的基本思想是：相邻记录的关键字两两比较，如果反序则交换，直到没有反序的记录为止。\n\n/* 冒泡排序初级版 *//* 时间复杂度： O(n^2) */void BubbleSort0(SqList *L)&#123;    int i,j;    for ( i = 1; i &lt; L-&gt;length; i++ ) &#123;        for( j = i + 1; j &lt;= L-&gt;length; j++ ) &#123;            if( L-&gt;r[i] &gt; L-&gt;r[j]) &#123;    //从小到大排序                swap(L, i, j);            &#125;            // if( L-&gt;r[i] &lt; L-&gt;r[j]) &#123;    //从大到小排序            //     swap(L, i, j);            // &#125;        &#125;    &#125;&#125;/* 冒泡排序 *//* 时间复杂度： O(n^2) */void BubbleSort(SqList *L)&#123;    int i, j;    for(i = 1; i &lt; L-&gt;length; i++) &#123;        for(j = L-&gt;length; j &gt; i; j--) &#123;            if(L-&gt;r[j] &lt; L-&gt;r[j-1]) &#123; //若后面的比前面的小，则交换                swap(L, j, j-1);            &#125;        &#125;    &#125;&#125;/* 冒泡排序优化 *//* 时间复杂度： O(n^2) */void BubbleSort2(SqList *L)&#123;    int i,j;    Status flag = TRUE;     //首轮循环为真    for(i = 1; i &lt; L-&gt;length &amp;&amp; flag; i++) &#123;        flag = FALSE;                   //每一轮初始都为FALSE        for(j = L-&gt;length; j &gt; i; j--) &#123;            if(L-&gt;r[j] &lt; L-&gt;r[j - 1]) &#123; //若后面的比前面的小，则交换                swap( L, j, j - 1);                flag = TRUE;            //如果有数据交换，将flag设为TRUE                                        /* 若没有数据交换，说明此序列已经排好序，不需要继续循环 */            &#125;        &#125;    &#125;&#125;\n\n\n\n简单选择排序（$O(n^2)$）\n选择排序的基本思想是每一趟在 $n-i+1(i&#x3D;1,2,…,n-1)$个记录中选取关键字最小的记录作为有序序列的第$i$个记录。\n尽管与冒泡排序的时间复杂度同为：$O(n^2)$，但简单选择排序的性能上还是要略微优于冒泡排序。\n\n\n/* 简单选择排序算法 *//* 时间复杂度： O(n^2) *///（我的理解：冒泡排序初级版的优化，就是不交换了，优化为每轮记录最小值（或最大值）的下标，这一轮循环结束后，只用交换一次就行。）void SelectSort(SqList *L)&#123;    int i,j,min;    for (i = 1; i &lt; L-&gt;length; i++) &#123;        min = i;                                //将当前下标定义为最小值下标        for (j = i+1; j &lt;= L-&gt;length; j++) &#123;    //循环之后的数据            if (L-&gt;r[j] &lt; L-&gt;r[min]) &#123;          //如果有小于当前最小值的关键字                min = j;                        //将此关键字的下标赋值给 min            &#125;        &#125;                   if(i != min) &#123;                          //若 min 不等于 i，说明找到最小值，则交换两者的值            swap(L, min, i);        &#125;    &#125;&#125;\n\n\n\n直接插入排序（$O(n^2)$）\n直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增 1 的有序表。\n是一种插入排序算法\n\n\n/* 直接插入排序算法 */void InsertSort(SqList *L)&#123;    int i,j;    for (i = 2; i &lt;= L-&gt;length; i++) &#123;          if (L-&gt;r[i] &lt; L-&gt;r[i-1]) &#123;          //如果后面小于前面，则需要将 L-&gt;r[i] 插入到有序表            L-&gt;r[0] = L-&gt;r[i];              //将待插入的保存到r[0]            for(j = i-1; L-&gt;r[j] &gt; L-&gt;r[0]; j--) &#123;                L-&gt;r[j+1] = L-&gt;r[j];        //记录后移            &#125;            L-&gt;r[j+1] = L-&gt;r[0];            //插入正确的位置        &#125;    &#125;&#125;\n\n希尔排序（$O(n^{3&#x2F;2})$）\n希尔排序是直接插入排序的改进版，它会优先比较距离较远的元素。\n希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。\n增量的选取是算法的核心，可究竟如何选取才好，目前还是一个数学难题，迄今为止没有人找到一种最好的增量序列。\n需要注意的是，增量序列的最后一个增量值必须等于 1 才行。\n由于希尔排序的记录是跳跃式的移动，希尔排序并不是一种稳定的排序算法。\n\n\n/* 希尔排序算法 */void ShellSort(SqList *L) &#123;    int i,j;    int increment = L-&gt;length;    do    &#123;        increment = increment/3 + 1;        for(i = increment + 1; i &lt;= L-&gt;length; i++) &#123;            if (L-&gt;r[i] &lt; L-&gt;r[i-increment]) &#123;                //需要将L-&gt;r[i]插入有序增量表                L-&gt;r[0] = L-&gt;r[i];                  //暂存在 L-&gt;r[0]                for(j = i-increment; j &gt; 0 &amp;&amp; L-&gt;r[0] &lt; L-&gt;r[j]; j -= increment) &#123;                    L-&gt;r[j+increment] = L-&gt;r[j];    //记录后移，查找插入位置                &#125;                L-&gt;r[j+increment] = L-&gt;r[0];        //插入            &#125;        &#125;    &#125; while (increment &gt; 1);&#125;\n\n\n\n堆排序（$O(nlogn)$）\n堆排序，就是对简单选择排序进行的一种改进。\n\n堆是具有以下性质的完全二叉树：\n\n每个结点的值都大于或等于其左右孩子的值，称为大顶堆；\n或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。\n\n\n堆排序就是利用堆进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走（其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值），然后将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次大值。如此反复执行，便能得到一个有序序列了。\n\n堆排序需要解决的两个问题：\n\n如何由一个无序序列构建成一个堆？\n如何在输出堆顶元素后，调整剩余元素成为一个新的堆？\n\n\n总体上看堆排序的时间复杂度为 O（nlogn）。由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为O(nlogn)。\n\n空间复杂度上，它只有一个用来交换的暂存单元，也非常的不错。不过由于记录的比较与交换是跳跃式进行，因此堆排序也是一种不稳定的排序方法。\n\n\n/* 堆排序算法 *//* 时间复杂度： O(n * logn) *//* 已知 L-&gt;[s..m] 中记录的关键字除 L-&gt;r[s] 之外均满足堆的定义 *//* 本函数调整 L-&gt;r[s] 的关键字，使 L-&gt;r[s..m] 成为 一个大顶堆 */void HeapAdjust(SqList *L, int s, int m)&#123;    int temp, j;    temp = L-&gt;r[s];    for (j = 2 * s; j &lt;= m; j *= 2) &#123;           //沿着关键字较大的孩子结点向下筛选        if(j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j+1]) &#123;            ++j;                                // j 为关键字较大的记录的下标        &#125;        if(temp &gt;= L-&gt;r[j]) &#123;            break;                              // rc 应插入在位置 s 上        &#125;           L-&gt;r[s] = L-&gt;r[j];        s = j;    &#125;    L-&gt;r[s] = temp;&#125;/* 堆排序算法 */void HeapSort(SqList *L)&#123;    int i;    for (i = L-&gt;length/2; i &gt; 0; i--) &#123; //把 L 中的 r 构建成一个大顶堆        HeapAdjust(L,i,L-&gt;length);    &#125;    for (i = L-&gt;length; i &gt; 1; i--) &#123;        swap(L, 1, i);          //将堆顶记录和当前未经排序子序列的最后一个记录交换        HeapAdjust(L, 1, i-1);  //将 L-&gt;r[1...i-1]重新调整为大顶堆    &#125;&#125;\n\n\n\n归并排序（$O(nlogn)$）\n归并：在数据结构中的含义就是：将两个或两个以上的有序表组合成一个新的有序表。\n\n归并排序是两两比较，不存在跳跃，因此归并排序是一种稳定的排序算法。\n\n归并排序是一种比较占用内存，但却效率高且稳定的算法。\n\n\n//将有序的SR[i..m]和SR[m+1..n]归并为有序的TR[i..n]void Merge(int SR[], int TR[], int i, int m, int n)&#123;    int j,k,l;    // i 为 SR[i..m]的下标； j 为 SR[m+1..n]的下标    j = m + 1;    for (k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) &#123;   //将 SR 中记录由小到大归并入 TR        if(SR[i] &lt; SR[j]) &#123;            TR[k] = SR[i++];        &#125;else&#123;            TR[k] = SR[j++];        &#125;    &#125;    if(i &lt;= m) &#123;        for(l = 0; l &lt;= m - i; l++) &#123;            TR[k+l] = SR[i+l];        &#125;    &#125;    if(j &lt;= n) &#123;        for(l = 0; l &lt;= n - j; l++) &#123;            TR[k+l] = SR[j+l];        &#125;    &#125;&#125;// 将 SR[s..t] 归并排序为 TR1[s..t]void MSort(int SR[], int TR1[], int s, int t)&#123;    int m;    int TR2[MAXSIZE + 1];    if(s == t) &#123;        TR1[s] = SR[s];    &#125;else&#123;        m = (s+t)/2;    // 将SR[s..t]平分为SR[s..m]和SR[m+1..t]        MSort(SR, TR2, s, m);   //递归将SR[s..m]归并为有序的TR2[s..m]        MSort(SR,TR2,m+1,t);     //递归将SR[m+1..t]归并为有序TR2[m+1..t]        Merge(TR2,TR1,s,m,t);   //将TR2[s..m]和TR2[m+1..t]归并到TR1[s..t]    &#125;&#125;//归并排序void MergeSort(SqList *L)&#123;    MSort(L-&gt;r, L-&gt;r, 1, L-&gt;length);&#125;\n\n\n\n快速排序（$O(nlogn)$）\n快速排序的基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分继续进行排序，以达到整个序列有序的目的。\n\n//交换顺序表 L 中子表的记录，使枢轴记录到位，并返回其所在位置 //此时在它之前（后）的记录均不大（小）于它int Partition(SqList *L, int low, int high)&#123;    int pivotkey;    pivotkey = L-&gt;r[low];   //用子表的第一个记录作枢轴记录    while( low &lt; high ) &#123;   //从表的        while(low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) &#123;            high--;        &#125;        swap(L, low, high); //将比枢轴记录小的记录交换到低端        while(low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) &#123;            low++;        &#125;        swap(L, low, high); //将枢轴记录大的记录交换到高端    &#125;    return low; //返回枢轴所在位置&#125;/* 对顺序表 L 中的子序列 L-&gt;r[low..high] 作快速排序 */void QSort( SqList *L, int low, int high)&#123;    int piovt;    if(low &lt; high)    &#123;        piovt = Partition(L, low, high);        //将L-&gt;r[low..high]一分为二                                                //算出枢轴值piovt        QSort(L, low, piovt-1) ;        //对低子表递归排序        QSort(L, piovt+1, high);        //对高子表递归排序    &#125;&#125;// 快速排序算法void QuickSort(SqList *L) &#123;    QSort(L, 1, L-&gt;length);&#125;\n\n\n\n小结\n\n\n希尔排序相当于直接插入排序的升级，它们同属于插入排序类。\n堆排序相当于简单选择排序的升级，他们同属于选择排序类。\n快速排序其实就是冒泡排序的升级，它们同属于交换排序类。\n\n我自己的感悟，简单算法升级为快速算法，就是合理的增大了比较和移动的距离。\n\nIf you want something, go get it. Period.","categories":["C","数据结构"],"tags":["DS笔记"]},{"title":"第二章——变量和基本类型","url":"/2022/04/29/Primer2/","content":"第二章——变量和基本类型对象\n对象是指：一块能存储数据并具有某种类型的内存空间\n\n对象是具有某种数据类型的内存空间。\n\n对象的类型决定了其上的操作。\n\n\n变量命名规范\n标识符要能体现实际含义\n变量名一般用小写字母，如 index，不要用 Index 或 INDEX\n用户自定义类名一般以大写字母开头，如 Sales_item\n如果标识符由多个单词组成，则单词间应有明显区分，如 student_loan 或 studentLoan，不要用studentloan\n\n变量定义的时机\n一般来说，在对象第一次被使用的地方附近定义它是一种好的选择，这样做有助于更容易的找到变量的定义。更重要的是，当变量的定义与它第一次被使用的地方很近时，我们会赋给它一个比较合理的初始值。\n\n复合类型\n指针（初始化所有指针）\n//空指针的定义：int *p1 = nullptr;\t\t// 等价于 int *p1 = 0; 这种方法最简单。最好使用这种。C11标准。int *p2 = 0;\t\t\t// 直接将 p2 初始化为字面常量 0// 需要首先#include cstdlibint *p3 = NULL;\t\t\t// 等价于 int *p3 = 0;\n\n\n\n引用\n\n\nP56 和 P534 页 两种例外\n除了两种例外情况外，其他所有引用的类型都要和与之绑定的对象严格匹配。  \n\n第一种例外就是，在初始化常量引用时允许用任意表达式作为初始值。（P56）\n？\n\n除了两种例外情况外，其他所有指针的类型都要和其指向的对象严格匹配。\n\n第一种例外就是，允许令一个指向常量的指针指向一个非常量的对象。\n\nconst对象仅在文件内有效\n默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const的变量时，其实等同于在不同文件中分别定义了独立的变量。\n有些时候有这样一种 const 变量，它的初始值不是一个常量表达式，但又确实又必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类 const 对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义 const ，而在其他多个文件中声明并使用它。解决方法是：对于const变量不管是声明还是定义都添加 extern 关键字，这样只需要定义一次就行了。\n\n引用 与 const\n要想绑定const对象，只能使用常量引用。\n\n常量引用是对 const引用。\n\n初始化和对 const 的引用\ndouble dval = 3.14;const int &amp;ri = dval;//执行这两条语句到底发生了什么？//发生了以下变化，编译器会把上述代码变成了如下形式：const int temp = dval;\t//有双精度浮点数生成一个临时的整型变量const int &amp;ri = temp;\t//让 ri 绑定这个临时量//这种情况下， ri 绑定了一个临时量对象。\n\n对 const 的引用可能引用一个并非 const 的对象\n此时，引用是 const ，但引用绑定的值是非 const 对象。不能通过引用改变对象的值，但是并不影响对象通过其他操作改变自己的值。\n\n\n指针 与 const\n要想存放const对象的地址，只能使用指向常量的指针。\n\n指针与引用不同，指针是对象而引用不是，因此就像其他对象一样，允许把指针本身定为常量。__常量指针__必须初始化，而且一旦初始化完成，则它的值就不能再改变了。\n\n也就是说，因为指针是对象，所以有了两种情况：\n\n常量指针：指针的指向不能变\n指向常量的指针：不能通过指针改变对象（这个对象可以是常量也可是非常量）的值。\n\n\n顶层const表示指针本身是一个常量，底层const表示指针所指的对象是一个常量。\n\n\n常量表达式\n是指，不会改变并 且 在编译过程中就能得到计算结果的表达式。\n\nconstexpr 常量，声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化：\nconstexpr int mf = 20;\t\t//20是常量表达式constexpr int limit = mf + 1; // mf + 1 是常量表达式constexpr int sz = size();\t//只有当 size 是一个constexpr函数时，才是一条正确的声明语句。\n\n必须指明一点，，在constexpr声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。\nconst int *p = nullptr;\t\t//p是一个指向整型常量的指针constexpr int *q = nullptr;\t//q是一个指向整数的常量指针\n\nq 和 p 相差甚远，p 是一个指向常量的指针，q 是一个常量指针。\n\n\n类型别名\n指针、常量和类型别名\ntypedef char *pstring;const pstring cstr = 0;\t\t//cstr是指向char的常量指针const pstring *ps;\t\t\t//ps是一个指针，它的对象是指向 char 的常量指针\n\nconst 是对给定类型的修饰。pstring 实际上是指向 char 的指针，因此，const pstring 就是指向 char 的常量指针，而非指向常量字符的指针。\n\nauto 类型说明符\n编程是常常需要把表达式的值赋给变量，这就要求在声明变量的时候清楚的知道表达式的类型。然而要做到这一点并非那么容易。\n为了解决这个问题，C++11 新标准引入了 auto 类型说明符，用它就能让编译器替我们去分析表达式所属的类型。\n显然，auto定义的变量必须有初始值。\n\ndecltype 类型指示符\n有时会遇到这种情况：希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量。\ndecltype(f()) sum = x;\t//sum的类型就是函数 f 的返回类型\n\n需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。\n\n\n","tags":["C++ Primer"]},{"title":"第三章——字符串、向量和数组","url":"/2022/04/30/Primer3/","content":"第三章——字符串、向量和数组两种重要的标准库类型：string 和 vector。string 表示可变长的字符序列，vector 存放的是某种给定类型对象的可变长序列。\n内置数组类型，和其他内置类型一样，数组的实现与硬件密切相关。因此比较于标准库类型 string 和 vector，数组在灵活性上稍显不足。\n1. 命名空间的 using 声明\n头文件不应该包含 using 声明\n\n标准库类型 String// --------string::size_type\t// string 类成员 size()的返回值类型，也是 string 的下标类型。// --------\n\n\n\n\n定义和初始化 string 对象\nstring s1;\t\t\t\t//默认初始化，s1 是一个空串string s2(s1);\t\t\t//s2 是 s1 的副本string s3(&quot;value&quot;); \t//s3是字面值&quot;value&quot;的副本，除了字面值最后的那个空字符外string s3 = &quot;value&quot;;\t//s3是字面值&quot;value&quot;，s3是字面值&quot;value&quot;的副本string s4(n, &#x27;c&#x27;);\t\t//把 s4 初始化为由连续 n 个字符 c 组成的串\n\n拷贝初始化 和 直接初始化\n\n切记，因为某些历史原因，也为了与C兼容，所以C++ 语言中的字符串字面值并不是标准库类型 string 的对象。\n字符串字面值与 string 是不同的类型。\n\n使用基于范围的 for 语句\n\n无论何时用到字符串的下标，都应该注意检测其合法性。\n\n\n标准库类型 vector// -------vector&lt;int&gt;::size_type  \t// vector&lt;int&gt; 对象的成员 size() 的返回值类型，同样也是 vector&lt;int&gt;下标类型// ------\n\n\n\n\n定义和初始化 vector 对象\nvector&lt;T&gt; v1\t\t\t// v1是一个空 vector， 它潜在的元素是T类型的，执行默认初始化vector&lt;T&gt; v2(v1)\t\t// v2中包含有 v1 所有元素的副本vector&lt;T&gt; v2 = v1   \t// 等价于 v2(v1)，v2中包含有 v1 所有元素的副本vector&lt;T&gt; v3(n, val)\t//v3包含了n个重复的元素，每个元素的值都是valvector&lt;T&gt; v4(n)\t\t\t//v4包含了n个重复地执行了值初始化地对象vector&lt;T&gt; v5&#123;a,b,c...&#125;  //v5包含了初始值个数地元素，每个元素被赋予相应地初始值vector&lt;T&gt; v5 = &#123;a,b,c...&#125;//等价于v5&#123;a,b,c...&#125; \n\nvector 对象（以及 string 对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。\n\n确保下标合法的一种有效手段就是尽可能使用范围 for 语句。\n\n\n迭代器\nvector 支持下标运算符，这点和 string 一样； string 支持迭代器，这也和 vector 是一样的。\n\n类似于指针类型，迭代器也提供了对对象的间接访问。\n\n有效的迭代器或者指向某个元素，或者指向容器中尾元素。\n// -----difference_type \t// 两迭代器相减得到距离的数据类型，带符号的整型数。// -----\n\n\n谨记，但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。\n\n数组// ------size_t\t\t// 位于头文件cstddef中 ,数组下标的数据类型 ， 是一种机器相关的无符号类型。// ------\n\n\n\n\n要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。\nint ia[] = &#123;0,1,2,3,4,5&#125;;\t// ia 是一个含有10个整数的数组int *beg = begin(ia);\t// 指向 ia 首元素的指针int *last = end(ia);\t// 指向 arr 尾元素的下一位置的指针// ---------begin() // 函数，用于计算数组首元素的指针， 定义在 iterator 头文件中end() // 函数，用于计算数组尾元素下一位置的指针// ---------\n\n\n\n// 两指针相减的数据类型constexpr size_t sz = 5;int arr[sz] = &#123;1，2，3，4，5&#125;;auto n = end(arr) - begin(arr);\t// 两指针相减的结果的类型是一种名为 ptrdiff_t 的标准库类型，和 size_t 一样也是一种定义在 cstddef头文件中的机器相关类型// -------ptrdiff_t\t// 位于cstddef中，begin()函数返回值的数据类型，// -------\n\n\n\n标准库类型 string 和 vector 也能执行下标运算，但是数组与它们相比还是有所不同。标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求，上面的最后一个例子很好地说明了这一点。\n\n尽管 C++ 支持 C 风格字符串，但是 C++ 程序中最好还是不要使用它们。\n\nC风格的字符串，不是一种类型，而是为了表达和使用字符串而形成的一种约定俗成的写法。按照此习惯书写的字符串存放在字符数组中并以空字符串结束（字符串后面跟一个空字符’\\0’）。一般用指针来操作这些字符串。\n\n\n对大多数应用来说，使用标准库 string 要比使用 C 风格字符串更安全，更高效。\n\n\n现代的 C++ 程序当尽量使用 vector 和迭代器，避免使用内置数组和指针；应尽量使用 string ，避免使用 C 风格的基于数组的字符串。\n\n\n严格来说，C++ 语言中没有多维数组，通常所说的多维数组其实是数组的数组。\n\n\n数组初始化局部元素，其他元素默认初始化为 0 。\n\n要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。\n\n\n数组和指向数组元素的指针在一个较低层次上实现了与标准库类型 string 和 vector 类似的功能。一般来说，应该优先选用标准库提供的类型，之后在考虑 C++ 语言内置的低层替代品数组或指针。\n\n类型别名声明，新标准\nusing int_array = int[4];\t// 新标准下类型别名的声明typedef int int_array[4];\t// 等价的 typedef 声明\n\n","tags":["C++ Primer"]},{"title":"第五章——语句","url":"/2022/05/16/Primer5/","content":"第五章——语句1.简单语句\n空语句：只有一个分号；如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。另外使用空语句时应该加上注释。\n空块的作用等价于空语句。\n\n2. 条件语句\n悬垂 else ，在 C++中，它规定 else 与离它最近的尚未匹配的 if 匹配，从而消除了程序的二义性。\n\nswitch 语句一般不要省略 case 分支最后的 break 语句。如果没写 break 语句，最好加一段注释说清楚程序的逻辑。\n\n尽管 switch 语句不是非得在最后一个标签后面写上 break，但是为了安全起见，最好这么做。因为这样的话，即使后面在增加新的 case 分支，也不用再在前面补充 break 语句了。\n即使不准备在 default 标签下做任何工作，定义一个 default 标签也是有用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没做。\n标签不应该孤零零地出现，它后面必须跟上一条语句或者另外一个 case 标签。如果 switch 结构以一个空的 default 标签作为结束，则该 default 标签后面必须跟上一条空语句或空块。\n如果需要为某个 case分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有 case 标签都在变量的作用域之外。\ncase 标签必须是整型常量表达式。\n\n\nC++ 语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。\n\n\n3. 迭代语句\n定义在 while 条件部分或者 while 循环体内的变量每次迭代都经历从创建到销毁的过程。\nfor语句头中的多重定义，和其他声明一样，可以定义多个对象。但是只能有一条声明语句，因此，所有变量的基础类型必须相同。\n\n4. 跳转语句\nbreak 语句的作用范围仅限于最近的循环或者 switch。\ncontinue 语句终止最近的循环中当前迭代并立即开始下一次迭代。\ncontinue 语句只能出现在 for、while和 do while循环的内部，或者嵌套在此类循环里的语句或块内部。\n\n5. 异常处理\n编写异常安全的代码非常困难\n\n","tags":["C++ Primer"]},{"title":"第四章——表达式","url":"/2022/05/10/Primer4/","content":"第四章——表达式1. 基础\n当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。\n\n算术运算符满足左结合律，意味着如果运算符的优先级相同，将按照从左向右的顺序组合运算对象。\n2. 算术运算符\n对于大多数运算符来说，布尔类型的运算对象将被提升为 int 类型。\n\n除了 -m 导致溢出的特殊情况，其他时候\n (-m)&#x2F;n 和 m&#x2F;(-n) 都等于 -(m&#x2F;n);\nm%(-n) 等于 m%n，(-m)%n 等于 -(m%n)。\n\n\n3. 逻辑运算符\n短路求值，逻辑与运算符或逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且精当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。\n\n进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象。\n// 如果想测试一个算术对象或指针对象的真值，最直接的方法就是将其作为 if 语句的条件// 如下所示：if (val) &#123; /*......*/ &#125;\t\t// 如果 val 是任意的非 0 值，条件为真if (!val) &#123; /*......*/ &#125;\t// 如果 val 是 0 ，条件为真\n\n4. 赋值运算符int ival, jval;ival = jval = 0;\n\n\n赋值语句满足右结合律，所以靠右的赋值运算 jval &#x3D; 0 作为靠左的赋值运算符的右侧运算对象。\n\n赋值语句经常会出现在条件中。因为赋值运算的优先级相对较低，所以通常需要给赋值部分加上括号使其符合我们的原意。\n// 这是一种形式繁琐、容易出错的写法int i = get_value();\t// 得到一个值while (i != 42) &#123;    // 其他处理...    i = get_value();\t// 得到剩下的值&#125;// 这是更好的写法：条件部分表达得更加清晰while ((i = get_value()) != 42) &#123;    // 其他处理...&#125;// 这个版本的 while 条件更容易表达我们的真实意图：不断循环读取数据直到遇到 42 为止。// 其处理过程是，首先将 get_value 函数的返回值赋值给 i ，然后比较 i 和 42 是否相等。\n\n切勿混淆相等运算符和赋值运算符\nif (i = j) &#123;    // ...&#125;// if 语句的条件把 j 的值赋值给 i，然后检查赋值的结果是否为真。如果 j 不为 0 ，条件将为真。// 想要的结果if (i == j) &#123;    // ...&#125;\n\n5. 递增和递减运算符\n很多迭代器本身不支持算术运算，所以此时递增和递减运算符除了书写简洁外还是必须的。\n\n除非必须，否则不用递增递减运算符的后置版本。\n前置版本的递增运算符避免了不必要的工作，他把值加 1 后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个未修改的内容。\n\n混用解引用和递增运算符\nauto pbeg = v.begin();// 输出元素直至遇到第一个负值为止while (pbeg != v.end() &amp;&amp; *pbeg &gt;= 0)     cout &lt;&lt; *pbeg++ &lt;&lt; endl;\t\t\t// 等价于如下语句\tcout &lt;&lt; *(pbeg++) &lt;&lt; endl;\t// 后置递增运算符的优先级高于解引用运算符// *pbeg 这种写法非常普遍，所以程序员一定要理解其含义\n\n提防复合表达式中，错用递增递减两个运算符。\nauto beg = s.begin();// 该循环是未定义的while (beg != s.end() &amp;&amp; !isspace(*beg))    *beg = toupper(*beg++);\t\t// 错误：该赋值语句未定义\n\n将产生未定义行为。问题在于：赋值运算符左右两端的运算对象都用到了 beg，并且右侧的运算对象还改变了 beg 的值，所以该赋值语句是未定义的。\n\n\n6. 成员访问运算符7. 条件运算符? :// 条件运算符// 随着条件运算嵌套层数的增加，代码的可读性急剧下降。因此，条件运算的嵌套最好别超过两到三层\n\n\n\n条件运算符满足右结合律，意味着运算对象（一般）按照从右向左的顺序组合。\n\n\n\n8. 位运算\n关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符用于处理无符号类型。\n\n\n移位运算的结果提升为 int 类型。\n\n位求反运算符，char 类型的运算对象首先提升为 int 类型，提升时运算对象原来的位保持不变，往高位添加 0 即可。\n\n\n重载运算的优先级和结合律都与它的内置版本一样。\n\n\n位移运算符满足左结合律\ncout &lt;&lt; &quot;hi&quot; &lt;&lt; &quot;there&quot; &lt;&lt; endl;// 等同于如下语句( (cout &lt;&lt; &quot;hi&quot;) &lt;&lt; &quot;there&quot; ) &lt;&lt; endl;// 在这条语句中，运算对象&quot;hi&quot;和第一个 &lt;&lt; 组合在一起，它的结果和第二个 &lt;&lt; 组合在一起，接下来的结果再和第三个 &lt;&lt; 组合在一起。(cout &lt;&lt; &quot;hi&quot;); // 该语句的运算结果是：cout \n\n9. sizeof 运算符\nsizeof 运算符返回一条表达式或一个类型名字所占的字节数。\nsizeof 运算符满足右结合律，其所得的值是一个 size_t 类型的常量表达式。\nsizeof 运算符不会实际求运算对象的值。\n\n\n一共有两种运算形式：\nsizeof(type);\t// 第一种sizeof expr;\t// 第二种，sizeof 返回的是表达式结果类型的大小。// 有趣的情况sizeof *p;\t// 因为 sizeof 运算符并不会求 *p 的值，所以即使 p 是一个无效的指针也不会有什么影响\n\nC++ 新标准允许我们使用作用域运算符来获取类成员的大小。\n\n\n10. 逗号运算符11. 类型转换\n编译器自动地转换运算对象的类型的情况：\n\n在大多数情况下，比 int 类型小的整型值首先提升为较大的整数类型\n在条件中，非布尔值转换为布尔类型\n初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。\n如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。\n函数调用时也会发生类型转换。\n\n\n\n整型提升\n整型提升，负责把小整数转换成较大的整数类型。对于 bool、char、signed char、unsigned char 、short 和 unsigned short 等类型来说，只要它们所有可能的值都能存在 int 里，它们就会提升为 int 类型；否则，提升为 unsigned int 类型。\n\n数组转换成指针\n在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。\n当数组被用作 decltype 关键字的参数，或者作为取地址符（&amp;）、sizeof 及 typeid 等运算符的运算对象时，上述转换不会发生。\n\n指针转换\n常量数值 0 或字面值 nullptr 能转换成任意指针类型；指向任意非常量的指针能转换成 void* ；指向任意对象的指针能转换成 const void* 。\n\n类类型的转换\nstring s;while (cin &gt;&gt; s) &#123;\t// while 的条件部分把 cin 转换成布尔值    //&#125;\n\n\n建议：避免强制类型转换\n就算无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，这样可以减少错误发生的机会。\n\n12. 小结对于含有超过一个运算符的表达式，要想理解其含义关键要理解优先级、结合律和求值顺序。每个运算符都有其对应的优先级和结合律，优先级规定了复合表达式中运算符的组合方式，结合律则说明当运算符的优先级一样时应该如何组合。\n大多数运算符并不明确规定运算对象的求值顺序：编译器有权自由选择先对左侧运算对象求值还是先对右侧运算对象求值。一般来说，运算对象的求值顺序对表达式的最终结果没有影响。但是，如果两个运算对象指向同一个对象而且其中一个改变了对象的值，就会导致程序出现不易发现的严重缺陷。\n","tags":["C++ Primer"]},{"title":"C++中的左值和右值","url":"/2022/06/07/leftaright/","content":"C++中的左值和右值C++ 的表达式要不然是右值，要不然就是左值。这两个名词是从 C 语言继承过来的，原本是为了帮助记忆：左值可以位于赋值语句的左侧，右值则不能。\n简单的归纳：\n\n当一个对象被用作右值的时候，用的是对象的值(内容)；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。\n\n一个重要的原则是在需要右值的地方可以用左值来代替，但是不能把右值当成左值使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。\n","tags":["C++ Primer"]},{"title":"第六章——函数","url":"/2022/05/24/Primer6/","content":"第六章——函数\n函数是一个命名了的代码块，我们通过调用函数执行相应的代码。\n\n1. 函数基础\n调用函数时，即使某个形参不被函数使用，也必须为它提供一个实参。\n\n函数的声明，因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。函数声明也称作函数原型。\n\n函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用该函数的全部信息。\n\n建议变量在头文件中声明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。\n\n声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。\n变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。\n\n\n含有函数声明的头文件应该被包含到定义函数的源文件中。\n\n\n\nChapter.h\t\t 头文件用于存放函数声明。\nfact.cpp \t\t  用于存放要使用的函数。\nfactMain.cpp   用于存放主函数，执行相应的功能。\n用以下指令进行分离式编译并执行\n# 第一步： 编译g++ fact.cpp factMain.cpp -o factMain# 第二步： 执行./factMain\n\n2. 参数传递const形参与实参\n和其他变量一样，形参的类型决定了形参和实参的交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。\n熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中，建议使用引用类型的形参替代指针。\n使用引用避免拷贝，拷贝大地类类型对象比较低效(典型的就是：string 类型，应使用引用以避免拷贝)，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。\n当函数需要多个返回值时，通过传引用形参的方式解决。\nC++ 允许我们用字面值初始化常量引用。\n尽量使用常量引用。把函数不会改变的形参定义成常量应该成为一种习惯。否则会有意想不到的后果。\n\n数组形参\n数组有两个特殊的性质，不允许拷贝数组以及使用数组时会将其转换成指针。\n\n管理指针形参的三种常用技术：\n\n使用标记指定数组长度\n使用标准库规范，传递指向数组首元素和尾后元素的指针。\n显式传递一个表示数组大小的形参，重写一个表示数组大小的形参。\n\n\n数组引用形参\nvoid print(int (&amp;arr)[10]) &#123;    for (auto elem : arr) &#123;        cout &lt;&lt; elem &lt;&lt; endl;    &#125;&#125;int main() &#123;    int i = 0, j[2] = &#123;0, 1&#125;;    int k[10] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;    // print(&amp;i);      //错误：实参不是含有10个整数的数组    // print(j);       // 错误：实参不是含有10个整数的数组    print(k);       // 正确：实参是含有10个整数的数组    return 0;&#125;\n\n传递多维数组，在C++语言中实际上没有真正的多维数组，所谓多维数组其实是数组的数组。\n多维数组，数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略。\nvoid print(int (*matrix) [4], int rowSize) &#123;    for (int i = 0; i != rowSize; ++i) &#123;        for (auto elem : *(matrix + i)) &#123;            cout &lt;&lt; elem &lt;&lt; endl;        &#125;    &#125;&#125;int main() &#123;    int matrix[3][4] = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,0,1,0&#125;&#125;;    print(matrix,3);    return 0;&#125;\n\nmain: 处理命令行选项// 测试 argc *argv[] 的功能// 将 test_6.exe int main(int argc,char *argv[])&#123;    string s = &quot;&quot;;    for (int i = 0; i != argc; ++i) &#123;        cout &lt;&lt; argv[i] &lt;&lt; endl;    &#125;\tsystem(&quot;pause&quot;);&#125;\n\n含有可变形参的函数void error_msg(initializer_list&lt;string&gt; il) &#123;    for (auto beg = il.begin(); beg != il.end(); ++beg) &#123;        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;\n\n3. 返回类型和 return 语句\nreturn语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。\n\n无返回值函数\n没有返回值的 return 语句只能用在返回类型是 void 的函数中。\n返回 void 的函数不要求非得有 return 语句，因为在这类函数的最后一句后面会隐式执行 return 。\n\n有返回值的函数\n在含有 return 语句的循环后面应该也有一条 return 语句，如果没有的话该程序应该就是错误的。很多编译器都无法发现此类错误。\n\n\n值是如何被返回的，返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。\n当对象在创建时获得了一个特定的值，我们说这个对象被初始化了。初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。\n\n\n要想确定返回值安全，我们不妨提问：引用所引的是在函数之前已经存在的哪个对象？\n\n引用返回左值，调用一个返回引用的函数得到左值，其他返回类型得到右值。\nchar &amp;get_val(string &amp;str, string::size_type ix) &#123;    return str[ix];     // get_val 假定索引值是有效的&#125;int main() &#123;    string s(&quot;a value&quot;);    cout &lt;&lt; s &lt;&lt; endl;      // 输出 a value    get_val(s, 0) = &#x27;A&#x27;;    // 将 s[0] 的值改为 A    cout &lt;&lt; s &lt;&lt; endl;      // 输出 A value    return 0;&#125;\n\n如果返回类型是常量引用，我们不能给调用的结果赋值，这一点和我们熟悉的情况是一样的。\n// 列表初始化返回值vector&lt;string&gt; process(int a) &#123;    if ( a &gt; 0) &#123;        return &#123;&#125;;    &#125; else if ( a == 0 ) &#123;        return &#123;&quot;sun&quot;, &quot;xing&quot;&#125;;    &#125; else &#123;        return &#123;&quot;sun&quot;, &quot;xing&quot;, &quot;hui&quot;&#125;;    &#125;&#125;vector&lt;int&gt; process_0(int a) &#123;    if ( a &gt; 0) &#123;        return &#123;1&#125;;    &#125; else if ( a == 0 ) &#123;        return &#123;1,2&#125;;    &#125; else &#123;        return &#123;1,2,3&#125;;    &#125;&#125;int main() &#123;    for ( auto c : process_0(-1)) &#123;        cout &lt;&lt; c &lt;&lt; endl;    &#125;       return 0;&#125;\n\n主函数 main 的返回值，我们允许 mian 函数没有 return 语句直接结束。如果控制到达了 main函数的结尾处而且没有 return 语句，编译器将隐式地插入一条返回 0 地 return 语句。\n\n\n返回数组指针虽然从语法上来说，要定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名。\n// 使用数组类型别名  typedef int arrT[10];      // arrT是一个类型别名，它表示的类型是含有10个整数的数组。 using arrT = int[10];      // arrT 等价声明。 arrT* func(int i);         // func 返回一个指向含有 10 个整数的数组的指针\n\n尾返回类型：\n\n这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。\n\n// func 接受一个 int 类型的实参，返回一个指针，该指针指向含有10个整数的数组auto func(int i) -&gt; int(*)[10];\n\n\narrPtr 使用关键字 decltype 表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。\n\nint odd[] = &#123;1,3,5,7,9&#125;;int even[] = &#123;0,2,4,6,8&#125;;// 返回一个指针，该指针向含有5个整数的数组decltype(odd) *arrPtr(int i) &#123;    return (i % 2) ? &amp;odd : &amp;even;  // 返回一个指向数组的指针&#125;\n\n\n\n4. 函数重载5. 特殊用途语言特性6. 函数匹配7. 函数指针","tags":["C++ Primer"]},{"title":"取模运算","url":"/2022/04/28/note1/","content":"取模运算背景取模运算（mod）和取余（rem）两个概念有重叠的部分，但又不完全一致；主要区别在于对负整数进行除法运算时操作不同。取模主要用于计算机术语中；取余则更多是数学概念。\n取模和取余的区别\n取余运算 在计算商值时，商值向 0 方向舍入；靠近 0 原则\n取模运算 在计算商值时，商值向负无穷方向舍入；尽可能让商值小的原则\n\n\n取模运算和求余数运算的计算方法相同：\n假设有两个整数，a和b。\n\n求商（整数）c :  \tc &#x3D; a&#x2F;b\n计算模或者余数：  r &#x3D; a - c*b\n\n\n不同之处在第一步，在计算 c 的值时\n__取模__——向负无穷方向舍入。\n__取余__——向0方向舍入。\n例子取模：\n\n\n\n简述\n商值\n\n取模值\n\n\n\n5 mod 3 &#x3D; 2\n5&#x2F;3 &#x3D; 1.66 商取小原则 商&#x3D;1\n5 - 3 * 1 &#x3D; 2\n2\n\n\n-5 mod 3 &#x3D; 1\n-5&#x2F;3 &#x3D; -1.66 商取小原则 商&#x3D;-2\n-5 - (3 * -2) &#x3D; 1\n1\n\n\n5 mod -3 &#x3D; -1\n5&#x2F;-3 &#x3D; -1.66 商取小原则 商&#x3D;-2\n5 - (-3 * -2) &#x3D; -1\n-1\n\n\n-5 mod -3 &#x3D; -2\n-5&#x2F;-3 &#x3D; 1.66 商取小原则 商&#x3D;1\n-5 - (-3 * 1) &#x3D; 2\n-2\n\n\n取余：\n\n\n\n简述\n商值\n\n取余值\n\n\n\n5 rem 3 &#x3D; 2\n5&#x2F;3 &#x3D; 1.66 商靠0原则 商&#x3D;1\n5 - 3 * 1 &#x3D; 2\n2\n\n\n-5 rem 3 &#x3D; -2\n-5&#x2F;3 &#x3D; -1.66 商靠0原则 商&#x3D;-1\n-5 - (3 * -1) &#x3D; - 2\n-2\n\n\n5 rem -3 &#x3D; 2\n5&#x2F;-3 &#x3D; -1.66 商靠0原则 商&#x3D;-1\n5 - (-3 * -1) &#x3D; 2\n2\n\n\n-5 rem -3 &#x3D; -2\n-5&#x2F;-3 &#x3D; 1.66 商靠0原则 商&#x3D;1\n-5 - (-3 * 1) &#x3D; - 2\n-2\n\n\n实例\n把 -1 赋给 8 比特大小的 unsinged char 所得的结果是 255 。\nunsinged char a = -1;std::cout &lt;&lt; a std::endl;\t// 输出为 -1 mod 2^8 = 255\n\n\n\nunsinged int u = 10;\nint i = -42;\n// 这里强制将 结果强制转换位无符号数，结果同 将运算结果赋值给无符号数的结果一样\nstd::cout &lt;&lt; u + i &lt;&lt; std::endl;\t//如果 int 占32位，输出 -42 mod 2^32 = 42949667264\n\n\n\n","tags":["取模"]},{"title":"底层const 与 顶层const","url":"/2022/06/02/note2/","content":"底层const与顶层const1.定义\n顶层const：表示对象本身是常量，对任何数据类型都适用，也包含常量指针，但通常不包括引用。\n底层const：表示指针&#x2F;引用所指的对象是常量，通常是指常量引用和指向常量的指针。\n\n2. 顶层const\n拷贝操作（a&#x3D;b):\n当b是一个顶层const类型时，仅仅意味着b的值不能改变，但并不影响传参。所以顶层const类型的对象作为被拷贝数据时，一般不受影响。\n\n参数传递 (实参–&gt; 形参):\n与拷贝操作类似，顶层const作为实参传递时，一般不受影响。\n\n\n3. 两种底层const: 指向常量的指针 和 常量引用\n非常量引用（或普通指针）不可以指向一个常量对象。若非如此，则可通过引用&#x2F;指针修改常量的值，显然与常量设计定义相违背。\n常量引用（或指向常量的指针）可以指向一个非常量对象。此时不可以通过引用或指针改变所指对象的值，但可通过其它方式改变。\n\n","tags":["const"]},{"title":"第一个博客","url":"/2022/03/20/testPaper/","content":"My first blog#include &lt;iostream&gt;int main()&#123;    std::cout&lt;&lt;&quot;My first!&quot;&lt;&lt;std::endl;    std::cout&lt;&lt;&quot;&quot;    return 0;&#125;\n\n","categories":["C/C++"],"tags":["原创"]},{"title":"C复习记录1","url":"/2022/03/21/C/C/","content":"C语言——复习记录11、在计算机内存中，整数一律采用补码形式来存储2、小数的长度是固定的，float始终占4个字节，double始终占8个字节3、wchar_t一种“数据类型”\n在微软编译器下，它的长度是2个字节，等价于unsinged short  \n在GCC&#x2F;LLVM&#x2F;Clang下，它的长度是4个字节，等价于unsigned int\n\n4、C语言字符编码\n对于 char 类型的窄字符，始终使用 ASCII 编码。\n对于 wchar_t 类型的宽字符和宽字符串，使用 UTF-16 或者 UTF-32 编码，它们都是基于 Unicode 字符集的。\n对于 char 类型的窄字符串，微软编译器使用本地编码，GCC、LLVM&#x2F;Clang 使用和源文件编码相同的编码。\n\n5、C语言的输入输出与缓冲区\n对于输出操作，清空缓冲区会使得缓冲区中的所有数据立即显示到屏幕上；很明显，这些数据没有地方存放了，只能输出了。\n对于输入操作，清空缓冲区就是丢弃残留字符，让程序直接等待用户输入，避免引发奇怪的行为。\n清空缓冲区方法：将输入缓冲区中的数据都读取出来。\n\n\n\n6、C语言的数组是静态的，大小不可变7、数组的越界和溢出\nC语言数组是静态的，不能自动扩容，当下标小于零或大于等于数组长度时，就发生了越界。\nC语言为了提高效率，保证操作的灵活性，并不会对越界行为进行检查，即使越界了，也能够正常编译，只有在运行期间才可能会发生问题。\n 由于C语言的”放任“，我们访问数组时必须非常小心，要确保不会发生越界。  \n\n8、递归\n要想让递归函数逐层进入再逐层退出，需要解决两个方面的问题:\n存在限制条件，当符合这个条件时递归便不再继续。对于 factorial()，当形参 n 等于 0 或 1 时，递归就结束了。\n每次递归调用之后越来越接近这个限制条件。对于 factorial()，每次递归调用的实参为 n - 1，这会使得形参 n 的值逐渐减小，越来越趋近于 1 或 0。\n\n\n\n\n尾递归，中间递归，多层递归，烧脑程度逐级上升。\n\n递归的时间开销极大，尽量用 迭代 来替换递归函数        \n  #include &lt;stdio.h&gt;#include &lt;time.h&gt;//斐波那契数列，求第n个斐波那契数。//递归法long func_digui(int n)&#123;\tif (n &lt;= 2)     &#123;\t\treturn 1;\t&#125;\telse\t&#123;\t\treturn func_digui(n - 1) + func_digui(n - 2);\t&#125;&#125;//迭代法long func_diedai(int n)&#123;\tlong p3;\tlong p2;\tlong p1;\tp2 = p1 = 1;\twhile (n &gt; 2)    &#123;        n -= 1;        p3 = p2;        p2 = p1;        p1 = p2 + p3;    &#125; return p1;&#125;int main()&#123;    int n;    long res1,res2;        printf(&quot;Input a number: &quot;);    scanf(&quot;%d&quot;, &amp;n);    clock_t time_start_recursion, time_end_recursion;    clock_t time_start_iteration, time_end_iteration;    //递归时间    time_start_recursion = clock();    res1 = func_digui(n);    printf(&quot;result = %ld\\n&quot;, res1);    time_end_recursion = clock();    printf(&quot;run time with recursion: %lfs\\n&quot;, (double)(time_end_recursion - time_start_recursion) / CLOCKS_PER_SEC);    //迭代的时间    time_start_iteration = clock();    res2 = func_diedai(n);    printf(&quot;result = %ld\\n&quot;, res2);    time_end_iteration = clock();    printf(&quot;run time with iteration: %lfs\\n&quot;, (double)(time_end_iteration - time_start_iteration) / CLOCKS_PER_SEC);    return 0;&#125;\n\n","categories":["C"],"tags":["原创"]},{"title":"C复习记录2","url":"/2022/03/21/C/C2/","content":"C语言——复习记录211、指针\n数据在内存中的地址也称为指针，如果一个变量存储了一份数据的指针，我们就称它为指针变量。\n未初始化的指针必须赋值为NULL，好习惯。\nvoid*，它不是空指针的意思，而是实实在在的指针，只是指针指向的内存中不知道保存的是什么类型的数据。\n\n12、字符串常量和字符数组\n字符数组和字符串常量（指向字符串的指针）的本质区别在于，在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。\n\n13、指针函数\n指的是某些返回值为指针变量的函数，成为指针函数。\n用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。\n\n14、数组名在什么时候会转换为指针？\nC语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、sizeof 或 &amp; 的操作数时，它才表示整个数组本身，在其他的表达式中，数组名会被转换为指向第 0 个元素的指针（地址）。\n\n15、数组下标[ ]\n就是对数组下标的引用总是可以写成“一个指向数组的起始地址的指针加上偏移量”\n作为函数形参时，以下三种形式等价，最后都会解释成第一种形式  void func(int *parr)&#123; ...... &#125;void func(int arr[])&#123; ...... &#125;void func(int arr[5])&#123; ...... &#125;\n最后都是指针（地址）。\n\n16、指针数组和二维数组的指针\n指针数组和二维数组的指针  int *(arr1[5]);  //可以去掉括号直接写作 int *p1[5];int (*p2)[5];   //二维数组的指针，不可去掉括号。[5]表示二维数组每行含有的元素个数。\n\n\n( ) 优先级高于 [ ]，[ ] 优先级高于 * 。优先级由高到低：\n定义中被括号( )括起来的那部分。\n后缀操作符：括号( )表示这是一个函数，方括号[ ]表示这是一个数组。\n前缀操作符：星号*表示“指向xxx的指针”。  int *p1[6];  //指针数组int *(p2[6]);  //指针数组，和上面的形式等价int (*p3)[6];  //二维数组指针int (*p4)(int, int);  //函数指针\n\n\n二维数组的指针实际指向一维数组，一维数组指针实际指向基本类型。\n\n17. -&gt; 在C语言中的唯一用途\n通过结构体指针直接取得结构体成员\n\n18. 枚举\n枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。\n这意味着，Mon、Tues、Wed 等都不是变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用&amp;取得它们的地址。这就是枚举的本质。\n\n19. 大小端\n大端模式（Big-endian）是指将数据的低位（比如 1234 中的 34 就是低位）放在内存的高地址上，而数据的高位（比如 1234 中的 12 就是高位）放在内存的低地址上。\n小端模式（Little-endian）是指将数据的低位放在内存的低地址上，而数据的高位放在内存的高地址上。数据的低位放在内存的低地址上，而数据的高位放在内存的高地址上。\n\n","categories":["C"],"tags":["原创"]},{"title":"C复习记录3","url":"/2022/03/21/C/C3/","content":"C语言——复习记录320、const与指针\nconst与指针  //以下三种组合方式const int *p1;int const *p2;int * const p3;\n  在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。\nconst 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。\n\n21、C语言中的地址（虚拟地址）\n把程序给出的地址看做是一种虚拟地址（Virtual Address），然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。这样，只要我们能够妥善地控制这个虚拟地址到物理地址的映射过程，就可以保证程序每次运行时都可以使用相同的地址\n\n22、内存对齐\n将一个数据尽量放在一个步长之内，避免跨步长存储，这称为内存对齐。在32位编译模式下，默认以4字节对齐；在64位编译模式下，默认以8字节对齐。\n为了提高存取效率，编译器会自动进行内存对齐\n内存对齐不是C语言的特性，它属于计算机的运行原理，C++、Java、Python等其他编程语言同样也会有内存对齐的问题。\n\n23、linux下C语言布局\n\n\n内存分区\n说明\n\n\n\n程序代码区(code)\n存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。\n\n\n常量区(constant)\n存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。\n\n\n全局数据区(global data)\n存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。\n\n\n堆区(heap)\n一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。\n\n\n动态链接库\n用于在程序运行期间加载和卸载动态链接库。\n\n\n栈区(stack)\n存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。\n\n\n24、sizeof()单目操作符\n用以获取数据类型额长度时必须加括号。\n\n25、野指针\n如果一个指针指向的内存没有访问权限，或者指向一块已经释放掉的内存，那么就无法对该指针进行操作，这样的指针称为野指针（Wild Pointer）\n规避野指针方法：\n指针变量如果暂时不需要赋值，一定要初始化为NULL，因为任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的。\n当指针指向的内存被释放掉时，要将指针的值设置为 NULL，因为 free() 只是释放掉了内存，并为改变指针的值。\n\n\n\n26、内存泄漏\n使用 malloc()、calloc()、realloc() 动态分配的内存，如果没有指针指向它，就无法进行任何操作，这段内存会一直被程序占用，直到程序运行结束由操作系统回收。\n在程序中使用 malloc() 分配内存时都对应地写出一个 free() 函数\n\n27、寄存器变量\n一般情况下，变量的值是存储在内存中的，CPU 每次使用数据都要从内存中读取。如果有一些变量使用非常频繁，从内存中读取就会消耗很多时间，这时就可以将变量存在寄存器中。\n\n28、全局变量\n它的作用域默认是整个程序，也就是所有的代码文件，包括.c和.h文件\n如果你一直在编写单个源文件的程序，那么请注意，全局变量的作用范围不是从变量定义处到该文件结束，在其他文件中也有效。\n\n29、extern\n  extern int m;   //变量的声明\n  int m = 100;    //变量的定义\n\n\n变量声明 与 定义 应该分开写。\nextern 是用来声明的，不管具体的定义是在当前文件内部还是外部，都是正确的。\n\n30、编译器和连接器\n编译器和连接器的一项重要任务就是将助记符替换位地址，一切都是地址。\n\n31、static变量作用（1）隐藏    程序有多个模块时，将全局变量或函数的作用范围限制在当前模块，对其他模块隐藏。（2）保持变量内容的持久化    将局部变量存储到全局数据区，使它不会随着函数调用结束而被销毁。  \n","categories":["C"],"tags":["原创"]},{"title":"数据结构——开场白","url":"/2022/03/22/DS/DS0/","content":"大话数据结构——开场白1、数据结构1.基本概念  \n\n\n数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。\n数据元素：是组成数据、具有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。\n数据项：一个数据元素由若干数据项组成。数据项是数据不可分割的最小单位。\n数据对象：是性质相同的数据元素的集合，是数据的子集。有时也将其成为数据。\n数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。  \n\n\n2.逻辑结构和物理结构  \n\n\n逻辑结构：数据对象中数据元素之间的相互关系。\n集合结构：集合结构中的数据元素，除了同属一个集合外，没有其他关系。\n线性结构：线性结构中数据元素之间是一对一的关系。\n树形结构：树形结构中的数据元素之间存在一种一对多的层次关系。\n图形结构：图形结构的数据元素是多对多的关系。\n\n\n物理结构：数据的逻辑结构在计算机中的存储结构。\n顺序存储：是把数据元素放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。\n链式存储：是把数据元素放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。\n\n\n\n\n2、算法\n对算法设计的要求:\n\n\n\n正确性：指的是算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。  \n可读性：\n健壮性：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结构。\n时间效率高 、存储量低\n\n\n\n时间复杂度（大O阶）\n\n\n常数阶、线性阶、平方阶、对数阶、nlogn阶、立方阶、指数阶。时间复杂度依次增大。  \n\n","categories":["C","数据结构"],"tags":["DS笔记"]},{"title":"数据结构——线性表","url":"/2022/03/26/DS/DS1/","content":"线性表0. 线性表的抽象数据类型\n\nADT 线性表（List）\nData线性表的数据对象集合为${a_1,a_2,a_3,…,a_n}$，每个数据元素的类型为DataType。其中，除第一个元素$a_1$外，每个元素有且只有一个直接前驱元素，除最后一个元素$a_n$外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。\nOperationInitList(*L):       初始化，建立一个空的线性表LListEmpty(L):       若线性表为空，返回true，否则返回false。ClearList(*L):      清空线性表。GetElem(L,i,*e):    将线性表L中的第i个元素返回给e。LocateElem(L,e):    在线性表中查找与给定值e相同的元素，如果查找成功，返回该元素在表中的序号表示成功；否则，返回-1表示失败。ListInsert(*L,i,e): 在线性的表的第i个位置插入新元素e。ListDelete(*L,i,*e):删除线性表L中第i个位置元素，并用e返回其值。ListLength(L):      返回线性表L的元素个数。\nendADT\n\n\n1. 线性表的顺序存储结构\n顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。\n\n优点：\n无须为表示表中元素的逻辑关系而增加额外的存储空间。\n可以快速的存取表中任意位置的元素。\n\n缺点：\n插入和删除操作需要移动大量元素。\n当线性表长度比较大时，难以确定存储空间的容量。\n\n2. 线性表的链式存储结构\n单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素。\n\n3. 顺序表和链表的优缺点（1）开辟空间的方式\n顺序表存储数据实行的是 “一次开辟，永久使用”，即存储数据之前先开辟好足够的存储空间，空间一旦开辟后期无法改变大小（使用动态数组的情况除外）。\n\n（2）空间利用率\n从空间利用率的角度上看，顺序表的空间利用率显然要比链表高，因为链表在存储数据时，每次只申请一个结点空间，且空间位置是随机的，这总申请存储空间的方式会产生很多空间碎片，一定程度上造成了空间浪费。不仅如此，由于链表中每个数据元素都必须携带至少一个指针，因此，链表对所有申请空间的利用率没有顺序表高。  \n\n空间碎片：指的是某些容量很小（1KB 甚至更小）以致无法得到有效利用的物理空间。\n\n\n（3）时间复杂度\n问题中主要涉及访问元素的操作，元素的插入、删除操作很少时，适合使用顺序表。因为访问顺序表的元素时间复杂度是O(1)；而在顺序表中插入、删除某个数据元素的时间复杂度是O(n)。  \n\n问题中主要设计元素的插入、删除和移动，访问元素的需求很少时，适合用链表。因为在链表中插入、删除数据元素的时间复杂度是O(1)；而访问链表的某个元素的时间复杂度是O(n)。  \n\n选择合适的存储结构会使得解决问题效率成倍数地提高。\n\n\n4. 存储结构和存取结构\n线性表的顺序存储结构是随机存取结构，而不是顺序存取结构；\n线性表的链式存储结构是顺序存取结构，而不是随机存取结构。\n\n5. 静态链表的优缺点\n优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。  \n\n缺点：没有解决连续存储分配带来的表长难以确定的问题，失去了顺序存储结构随机存取的特性。 \n\n总的来说，静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。\n\n\n6. 循环链表7. 双向链表8. 双向循环链表","categories":["C","数据结构"],"tags":["DS笔记"]},{"title":"数据结构——串","url":"/2022/03/31/DS/DS3/","content":"开场\n串的逻辑结构和线性表很相似，不同之处在于串针对的是字符集，也就是串中的元素都是字符。\n串的基本操作与线性表是有很大差别的。线性表更加关注的是单个元素的操作，比如查找一个元素，插入或删除一个元素，但串中更多是查找子串的位置、得到指定位置字串、替换字串等操作。\n\n串的抽象数据类型\nADT  \n\n串（String）\n\nData  \n\n串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。\n\nOperation  \n\nStrAssign(T, * chars)：生成一个其值等于字符串常量chars的串T。\nStrCopy(T,S)：串S存在，由串S复制得串T。\nClearString(S)：串S存在，将串清空。\nStringEmpty(S)：若串S为空，返回true，否则返回false。\nStrLength(S)：返回串S的元素个数，即串的长度。\nStrCompare(S,T)：若 S &lt; T,返回值&gt; 0，若S&#x3D;T ，返回0，若S &lt; T ，返回值 &lt; 0 。\nConcat(T,S1,S2)：用T返回由S1和S2联接而成的新串。\nSubString(Sub,S,pos,len)：串S存在，1 &lt;&#x3D; pos &lt;&#x3D; StrLength(S)，且0 &lt;&#x3D; len &lt;&#x3D; StrLength(S) - pos +1,用Sub返回串S的第pos个字符起长度为len的字串。\nIndex(S,T,pos)：串S和T存在，T是非空串，1 &lt;&#x3D; pos &lt;&#x3D; StrLength(S)。若主串S中存在和串T值相同的子串，则返回他在主串S中第pos个字之后第一次出现的位置，否则返回0。\nReplace(S,T,V)：串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的字串。\nStrInsert(S,pos,T)：串S和串T存在，1 &lt;&#x3D; pos &lt;&#x3D; StrLength(S) + 1。在串S的第pos个字符之前插入串T。\nStrDelete：串S存在，1 &lt;&#x3D; pos &lt;&#x3D; StrLength(S)-len + 1。从串S中删除第pos个字符起长度为len的字串。\n\nendADT \n\n串存储结构的三种实现方法\n定长顺序存储：普通的数组（又称为静态数组）存储。\n堆分配存储：用动态数组存储字符串。\n块链存储：用链表存储字符串。\n链表各个结点存储数据个数的多少可参考以下几个因素\n串的长度和存储空间的大小：若串包含数据量很大，且链表申请的存储空间有限，此时应尽可能的让各个节点存储更多的数据，提高空间的利用率（每多一个节点，就要多申请一个指针域的空间）；反之，如果串不是特别长，或者存储空间足够，就需要再结合其他因素综合考虑。\n程序实现的功能：如果实际场景中需要对存储的串做大量的插入或删除操作，则应尽可能减少各结点存储数据的数量；反之，需要再结合其他因素。\n\n\n\n\n\n朴素的串的模式匹配算法\n子串在一个主串的定位操作,通常称做串的模式匹配\n\nKMP模式匹配算法代码。\n","categories":["C","数据结构"],"tags":["DS笔记"]},{"title":"数据结构——栈与队列","url":"/2022/03/30/DS/DS2/","content":"\n开场\n栈是限定仅在队尾进行插入和删除操作的线性表。\n队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。\n\n栈的抽象数据类型\nADT  \n\n栈（stack）\n\nData  \n\n同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。\n\nOperation  \n\nInitStack(*S)：初始化操作，建立一个空栈S。\nDestroyStack(*S)：若栈存在，则销毁它。\nClearStack(*S)：将栈清空。\nStackEmpty(*S)：若栈为空，返回true，否则返回false。\nGetTop(S,*e)：若栈存在且空，用e返回S的栈顶元素。\nPush(*S,e)：若栈S存在，插入新元素e到栈中并成为栈顶元素。\nPop(*S,*e)：删除栈S中栈顶元素，并用e返回其值。\nStackLength(S)：返回栈S的元素个数。\n\nendADT  \n\n顺序栈与链栈对比\n时间性能\n两者的压栈与弹栈的时间复杂度都是 O(1)。\n\n\n空间性能\n顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题。但是它的优势是存取时定位很方便。\n链栈要求每个元素都有自己的指针域，这同样也增加了一些内存开销。但它的优势是栈的长度无限制。\n如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈。\n\n\n栈与队列\n栈是限定仅在表尾进行插入和删除操作的线性表。栈是先进后出的线性表\n队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。队列是先进先出的线性表。\n\n\n\n队列的抽象数据类型\nADT \n\n队列（Queue）\n\nData  \n\n同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。\n\nOperation\n\nInitQueue(*Q): 初始化操作，建立一个空队列Q。\nDestroyQueue(*Q)：若队列存在，则销毁它。\nClearQueue(*Q)：将队列Q清空。\nQueueEmpty(Q)：若队列Q为空，返回true，否则返回false。\nGetHead(Q,*e)：若队列Q存在且非空，用e返回队列Q的队头元素。\nEnQueue(*Q,e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。\nDeQueue(*Q,*e)：删除队列Q中对头元素，并用e返回其值。\nQueueLength(Q)：返回队列Q的元素个数\n\nendADT  \n\n顺序循环队列和链队列\n时间性能\n两者的基本操作都是常数时间，时间复杂度都为 O(1)。\n循环队列是事先申请好的空间，使用期间不释放，而链队列每次申请和释放结点也会存在一些时间开销，如果入队出队频繁，则两者还是有细微差别。\n\n\n空间性能\n循环队列必须有一个固定的长度，所以就有了存储元素个数和空间浪费的问题。\n链队列不存在这个问题，尽管它需要一个指针域，会产生一些空间上的开销，但也可以接受。\n在空间上链队列更加灵活。\n\n\n总的来说，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度，则用链队列。\n\n","categories":["C","数据结构"],"tags":["DS笔记"]},{"title":"数据结构——树","url":"/2022/04/04/DS/DS4/","content":"开场\n树是 n 个结点的有限集。n&#x3D;0 时称为空树。\n在任意一棵非空树中：\n有且仅有一个特定的称为根的结点；\n当 n &gt; 1 时，其余结点可分为 m (m &gt; 0)  个互不相交的有限集 $ T_1, T_2, T_3, …, T_m $，其中每一个集合本身又是一棵树，并且称为根的子树。\n\n\n注意以下两点：\nn &gt; 0 时，根结点是唯一的，不可能存在多个根节点。\nm &gt; 0 时，子树的个数没有限制，但它们一定是互不相交的。\n\n\n\n树与线性表的对比\n\n\n线性结构\n树\n\n\n\n第一个数据元素，无前驱\n根节点，无双亲，唯一\n\n\n最后一个数据元素，无后继\n叶节点，无孩子，可以多个\n\n\n中间元素，一个前驱一个后继\n中间结点，一个双亲多个孩子\n\n\n树的抽象数据类型\nADT\t\n\n树（tree）\n\nData\n\n树是由一个根节点和若干棵子树构成。树中结点具有相同数据类型及层次关系。\n\nOperstion\n\nInitTree( *T )：构造空树。\nDestroyTree( *T )：销毁树 T。\nCreateTree( *T,  definition )：按 definition 中给出树的定义来构造树。\nClearTree( *T )：若树T存在，则将树T清为空树。\nTreeEmpty( T )：若 T 为空树，返回 true，否则返回 false。\nTreeDepth( T )：返回 T 的深度。\nRoot( T )：返回T的根节点。\nValue( T, cur_e )：cur_e 是树 T 中一个结点，返回此节点的值。\nAssign( T, cur_e, value )：给树 T 的结点 cur_e 赋值为 value。\nParent( T, cur_e )：若cur_e是树 T 的非根结点，则返回它的双亲，否则返回空。\nLeftChild( T, cur_e )：若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空。\nRightSibling( T, cur_e )：若 cur_e 有兄弟，则返回它的左右兄弟，否则返回空。\nInsertChild( *T, *p, i, c )：其中 p 指向树 T 的某个结点，i 为所指结点 p 的度加上1，非空树 c 与 T  不相交，操作结果为插入 c 为数 T 中 p 指结点的第 i 棵子树。\nDeleteChild( *T, *p, i)：其中 p 指向树 T 个某个结点，i 为所指结点 p 的度， 操作结果为删除 T 中 p 所指结点的第 i 棵子树。\n\nendADT\n\n树的存储结构（1）双亲表示法/* 树的双亲表示法结点结构定义 */#define MAX_TREE_SIZE 100typedef int TElemType;\t// 树结点的数据类型，目前暂定为整型typedef struct PTNode\t/* 结点结构 */&#123;\tTElemType data;\t//结点数据\tint parent;\t\t//双亲位置&#125;PTNode;typedef struct\t\t/* 结点数组 */&#123;\tPTNode nodes[MAX_TREE_SIZE];\t// 结点数组\tint r, n;\t\t\t\t// 根的位置和结点数&#125;PTree;\n\n（2）孩子表示法/* 树的孩子表示法结构定义 */#define MAX_TREE_SIZE 100typedef struct CTNode\t//孩子结点&#123;\tint child;\tstruct CTNode *next;&#125; *ChildPtr;typedef struct\t\t\t//表头结点&#123;\tTElemType data;\tChildPtr firstchild;&#125; CTBox;typedef struct\t\t\t//树结构&#123;\tCTBox nodes[MAX_TREE_SIZE];\t//结点数组\tint r, n;\t\t//根的位置和结点数&#125; CTree;\n\n（3）孩子双亲表示法/* 孩子双亲表示法结构定义 *///该结构是前两者的结合#define MAX_TREE_SIZE 100typedef struct CTNode\t/* 孩子结点 */&#123;\tint child;\tstruct CTNode *next;&#125; *ChildPtr;typedef struct\t\t\t/* 表头结点 */&#123;\tTElemType data;\tint parent;\t\t\t//双亲的位置 \tChildPtr firstchild;\t&#125; CTBox;typedef struct\t\t\t/* 树结构 */&#123;\tCTBox nodes[MAX_TREE_SIZE];\t//结点数组\tint r, n;\t\t//根的位置和结点数&#125; CTree;\n\n（4）孩子兄弟表示法\n 此种方法最大的好处就是：它把一棵复杂的树变成了一棵二叉树\n\n/* 孩子兄弟表示法结构定义 */typedef struct CSNode&#123;\tTElemType data;\tstruct CSNode *firstchild, *rightsib;&#125;CSNode,*CTree;\n\n二叉树（1）二叉树特点\n每个结点最后有两棵子树。\n左子树和右子树是有顺序的，次序不能颠倒。\n即使树中某个结点只有一棵子树，也要区分它是左子树还是右子树。\n二叉树的五种基本形态：\n空二叉树。\n只有一个根节点。\n根结点只有左子树。\n根结点只有右子树。\n根结点既有左子树，又有右子树。\n\n\n特殊二叉树\n斜树\n满二叉树\n完全二叉树\n\n\n\n（2）二叉树性质\n性质 1：在二叉树的第 $i$ 层上至多有 $2^{i-1}$ 个结点。$ (i\\geq1) $\n性质 2：深度为 $ k $ 的二叉树至多有 $ 2^k-1 $ 个结点。 $ (k\\geq1)$\n性质 3：对任何一个二叉树 T，如果终端结点数为 $ n_0 $ ，度为 2 的结点数为 $ n_2 $，则 $ n_0 &#x3D; n_2 + 1$。\n性质 4：具有 $ n $ 个结点的完全二叉树的深度为 $ ⌊\\log_{2}{n}⌋ + 1 $  ( $ ⌊x⌋ $ 表示不大于 $ x $ 的最大整数）。\n性质 5：如果对一棵有 $ n $ 个结点的完全二叉树（其深度为 $ ⌊ \\log _ {2} {n}  ⌋  + 1 $ ）的结点按层序号编号（从第 $ 1 $ 层到第 $ ⌊\\log _ {2}{n}⌋ + 1 $ 层，每层从左到右），对任一结点 $i ( 1 \\leq i \\leq n ) $ 有：\n如果 $ i &#x3D; 1 $ ，则结点 $ i $ 是二叉树的根，无双亲；如果 $ i &gt; 1 $，则其双亲是结点 $  ⌊i&#x2F;2⌋ $。\n如果 $ 2i &gt; n $ ，则结点 $ i $ 无左孩子（结点 $ i $ 为叶子结点）；否则其左孩子是结点 $ 2i $ 。\n如果 $ 2i+1&gt;n $ ，则结点 $ i $ 无右孩子；否则其右孩子是结点 $ 2i + 1 $。\n\n\n\n二叉树的存储结构（1）二叉树的顺序存储结构\n这种存储方式适合存储完全的二叉树，一般的二叉树用这种方式存储会造成存储空间的浪费。\n\n（2）二叉链表\n二叉树的每个结点有一个数据域、两个指针域。称这种链表为二叉链表。\n\n/* 二叉树的二叉链表结点结构定义 */typedef struct BiTNode&#123;\t/*结点结构*/    TElemType data;\t//结点数据    struct BiTNode *lchild, *rchild;\t//左右孩子指针&#125;BiTNode,*BiTree;\n\n\n如同讨论树的存储结构一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为三叉链表。\n\n（3）二叉树遍历\n二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。\n前序遍历：规则是若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。\n中序遍历：规则是若树为空，则空操作返回，否则从根节点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根节点，最后中序遍历右子树。\n后序遍历：规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根节点。\n\n线索二叉树（1）二叉树的线索化\n线索化的过程即为在遍历过程中，将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。\n\n（2）线索二叉树的遍历\n使用线索二叉树时，会经常遇到一个问题就是：有的结点的直接后继可以通过指针域获得，而由于有些结点的度为2（也就是有两个孩子），无法利用指针域获得后继，整个链表断掉了。当在遍历过程中遇到这种问题的解决办法就是：寻找先序、中序、后序遍历的规律，找到下一个结点。\n\n\n\n在前序遍历过程中，如果结点因为有右孩子导致无法找到其后继结点，如果结点有左孩子，则后继结点是其左孩子；否则就一定是右孩子。\n在中序遍历过程中，如果结点因为有右孩子导致无法找到其后继结点，结点的后继是遍历其右子树时访问的第一个结点，也就是右子树中位于最左下的结点。反之，结点的前驱时左子树最后访问的那个结点。\n后续遍历中找后继结点需要分 3 种情况：\n如果该结点是二叉树的根，后继结点为空；\n如果该结点是父节点的右孩子（或者是左孩子，但是父节点没有右孩子），后继结点是父节点；\n如果该结点是父节点的左孩子，且父结点有右子树，后继结点为父结点的右子树在后序遍历列出的第一个结点。（使用后序遍历建立的线索二叉树，在真正使用过程中遇到链表的断点时，需要访问父结点，所以在初步建立二叉树时，宜采用三叉链表做存储结构。）\n\n\n\n\n\n中序遍历二叉树线索表表示的二叉树T，相当于对链表的扫描，时间复杂度为 O(n)。\n实际问题中，如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉表的存储结构就是非常不错的选择。\n\n树、森林与二叉树的转换（1）树转换为二叉树\n加线。在所有兄弟结点之间加一条连线\n去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。\n层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的孩子，兄弟转换过来的孩子是结点的右孩子。\n\n（2）森林转换为二叉树\n把每棵树树转换为二叉树。\n第一棵二叉树不动，从第二棵树开始，依次把后一棵树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。\n\n（3）二叉树转换为树\n加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、这个左孩子的右孩子结点的右孩子结点、这个左孩子的右孩子结点的右孩子结点的右孩子结点……。反正就是左孩子的 n 个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。\n去线。删除原二叉树中所有结点与其右孩子结点的连线。\n层次调整。使之结构层次分明。\n\n（4）二叉树转换为森林\n判断一棵二叉树能够转换为一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。\n\n\n从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。\n再将每棵分离后的二叉树转换为树即可。\n\n（5）树与森林的遍历\n树的遍历分为两种方式\n第一种：先根遍历，即先访问树的根结点，然后依次先根遍历根的每棵子树。\n第二种：后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。\n\n\n森林的遍历分为两种方式\n第一种：前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样的方式遍历除去第一棵树的剩余树构成的森林。\n第二种：后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。\n\n\n经分析可以发现：树的先根遍历和二叉树的前序遍历结果相同，树的后根遍历和二叉树的中序遍历结果相同。\n所以，当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历算法实现。\n\n赫夫曼树\n路径长度：从树的一个结点到另一个结点之间的分支结构构成两个结点之间的路径，路径上的分支数目称做路径长度。\n树的路径长度：就是从根结点到每一个结点的路径长度之和。\n结点的带权路径长度：从该结点到树根结点之间的路径长度与结点上权的乘积。\n树的带权路径长度：所有叶子结点带权路径长度之和。\n带权路径长度 WPL 最小的二叉树称做赫夫曼树。\n\n","categories":["C","数据结构"],"tags":["DS笔记"]},{"title":"数据结构——图","url":"/2022/04/09/DS/DS5/","content":"开场\n图（Graph）是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为：G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。\n对于图的定义需要明确：\n线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点。\n线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。图不允许没有顶点。\n线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。\n\n\n在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。无向完全图有$\\frac{n*(n-1)}{2}$条边。\n在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。有向完全图有$n*(n-1)$条边。\n有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的树叫做权。这种带权的图通常称为网。\n树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不唯一的。\n\n\n如果一个图有 n 个顶点和小于 n-1 条边，则是非联通图，如果它多于 n-1 边条，必定构成一个环。不过有 n-1 条边并不一定是生成树。\n\n无向图中连通且 n 个顶点 n-1 条边叫生成树。\n\n\n图的抽象数据类型\nADT\t\n\n图（Graph）\n\nData\n\n顶点的有穷非空集合和边的集合。\n\nOperation\n\nCreateGraph(*G,V,VR)：按照顶点集 V 和边弧集 VR 的定义构造图 G。\nDestroyGraph(*G)：图 G 存在则销毁。\nLocateVex(G,u)：若图 G 中存在顶点 u ,则返回图中的位置。\nGetVex(G,v)：返回图 G 中顶点 v 的值。\nPutVex(G,v,value)：将图 G 中顶点 v 赋值 value。\nFirstAdjVex(G,*v)：返回顶点 v 的一个邻接顶点，若顶点在 G 中无邻接顶点返回空。\nNextAdjVex(G,v,*w)：返回顶点 v 相对于顶点 w 的下一个邻接顶点，若 w 是 v 的最后一个邻接点则返回”空“。\nInsertArc(*G,v,w)：在图中增添弧&lt;v,w&gt;，若 G 是无向图，还需要增添对称弧 &lt;w,v&gt;。\nDeleteArc(*G,v,w)：在图 G 中删除弧&lt;v,w&gt;，若 G 是无向图，则还删除对称弧 &lt;w,v&gt;。\nDFSTraverse(G)：对图 G 中进行深度优先遍历，在遍历过程对每个顶点调用。\nHFSTraverse(G)：对图 G 中进行广度优先遍历，在遍历过程对每个顶点调用。\n\nendADT\n\n图的存储结构（1）邻接矩阵\n顺序存储结构\n\ntypedef char VertexType;\t//顶点类型typedef int EdgeType;\t\t//边上的权值类型#define MAXVEX 100\t\t\t//最大顶点数#define INFINITY 65535\t\t//用65535来代表∞/* 邻接矩阵 */typedef struct&#123;\tVertexType vexs[MAXVEX];\t\t\t//顶点表\tEdgeType arc[MAXVEX][MAXVEX];\t\t//邻接矩阵，边表\tint numVertexes, numEdges;\t\t\t//图中当前的顶点数和边数&#125;MGraph;\n\n（2）邻接表\n同时适用于无向图和有向图的存储结构\n\ntypedef char VertexType;\t//顶点类型typedef int EdgeType;\t\t//边上的权值类型#define MAXVEX 100\t\t\t//最大顶点数#define INFINITY 65535\t\t//用65535来代表∞/* 邻接表 *///边表结点结构typedef struct EdgeNode &#123;\t\tint adjvex;\t\t\t\t//邻接点域，存储该顶点对应的下标\tEdgeType weight;\t\t//用于存储权值，对于非网图可以不需要\tstruct EdgeNode* next;&#125;EdgeNode;//顶点表结点结构typedef struct VertexNode &#123;\tVertexType data;\t\t//顶点域，存储顶点信息\tEdgeNode* firstedge;\t//边表头指针&#125;VertexNode,AdjList[MAXVEX];//邻接表typedef struct &#123;\tAdjList adjList;\tint numVertexs, numEdges;\t//图中当前顶点数和边数&#125;GraphAdjList;\n\n\n\n（3）十字链表\n多适用于有向图，是邻接表和逆邻接表的结合。\n\ntypedef char VertexType;typedef int EdgeType;#define MAXVEX 100/***** 十字链表 *****///边表结点结构typedef struct EdgeNode &#123;\tint headvex;\t\t\t\t//指向弧起点在顶点表的下标，入\tint tailvex;\t\t\t\t//指向弧终点在顶点表的下标，出\tEdgeType weight;\t\t\t//用于存储权值，对于非网图可以不需要\tstruct EdgeNode* headlink;\t//指向终点相同的下一条边，入\tstruct EdgeNode* taillink;\t//指向起点相同的下一条边，出&#125;EdgeNode;//顶点表结点结构typedef struct VertexNode &#123;\tVertexType data;\t\t//顶点域，存储顶点信息\tEdgeNode* firstin;\t\t//表示入边表指针，指向该顶点的入边表的第一个结点，入\tEdgeNode* firstout;\t\t//表示出边表指针，指向该顶点的出边表的第一个结点，出&#125;VertexNode, CroList[MAXVEX];//十字链表typedef struct &#123;\tCroList croList;\tint numVertexs, numEdges;\t//图中当前顶点数和边数&#125;GraphCroList;\n\n\n\n（4）邻接多重表\n__仅适用于无向图，无向图邻接表的优化，便于访问图的边__。\n\ntypedef char VertexType;typedef int EdgeType;#define MAXVEX 100/***** 邻接多重表 *****///边表结点结构typedef struct EdgeNode &#123;\tint ivex;\t\t\t\t//ivex 和 jvex是与某条边依附的两个顶点在顶点表中的下标。\tint jvex;\t\t\t\t\tstruct EdgeNode* ilink; //指向依附顶点ivex的下一条边\tstruct EdgeNode* jlink;\t//指向依附顶点jvex的下一条边&#125;EdgeNode;//顶点表结点结构typedef struct VertexNode &#123;\tVertexType data;\t\t//顶点域，存储顶点信息\tEdgeNode* firstedge;\t\t//指向一条边 顶点下标与ivex值相同&#125;VertexNode, AdjmList[MAXVEX];//邻接多重表typedef struct &#123;\tAdjmList adjmlist;\tint numVertex, numEdge;&#125;GraphAdjmList;\n\n\n\n（5）边集数组\n详见 Kruskal算法（克鲁斯卡尔算法）\n\n图的遍历\n图的遍历，从图中某一顶点出发访遍图中其余顶点，且使每一顶点仅被访问一次，这一过程叫做图的遍历。\n\n（1）深度优先遍历算法\n所谓深度优先遍历，类似于树的前序遍历，是从图中的一个顶点 v 出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。\n深度优先搜索是一个不断回溯的过程，递归的过程。\n\n（2）广度优先遍历算法\n所谓广度优先遍历，类似于树的层序遍历，从图中某顶点 v 出发，在访问了 v 之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。\n\n最小生成树（1）普利姆（Prim）算法\n适用于稠密图，就是边数非常多的图。\n\n（2）克鲁斯卡尔（Krukal)算法\n该算法针对边来展开，边数少时效率会非常高。\n\n最短路径（1）迪杰斯特拉（Dijkstra ）算法（2）弗洛伊德（Floyd)算法拓扑排序\n最小生成树和最短路径都是有环的图的应用，拓扑排序是无环的应用。 \n在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们称为AOV网。\n所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程。构造时有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环的AOV网；如果输出顶点少了，哪怕是少了一个，也说明这个网存在环，不是AOV网。\n__拓扑排序方案并不唯一__，我的理解是有很多种，取决于你释放入度为0的顶点的顺序。\n\n关键路径\n在一个表示工程的带权有向图中，用顶点表示事件，用有向图表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网，我们称之为AOE网。\n没有入边的顶点称为始点或源点，没有出边的顶点称为终点或汇点。正常情况下，AOE网只有一个源点一个汇点。\n尽管AOE网与AOV网都是用来对工程建模的，但它们还是有很大不同，主要体现在：\nAOV网是顶点表示活动的网，它只描述活动之间的制约关系。\nAOE网是用边表示活动的网，边上的权值表示活动持续的时间。\n\n\n我们把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大长度的路径叫__关键路径，在关键路径上的活动叫关键活动__。\n\n图小结\n图的存储结构一共学了五种，常用的是邻接矩阵和邻接表。用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较少的图，用邻接矩阵要更合适，反之应该考虑邻接表。十字链表是针对有向图邻接表结构的优化，邻接多重表是针对无向图邻接表结构的优化，边集数组更多考虑的是对边的关注。\n图的应用：最小生成树、最短路径、有向无环图的拓扑排序和关键路径。\n\n","categories":["C","数据结构"],"tags":["DS笔记"]}]