<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="sxhpai">
    
    <title>
        
            第六章——函数 |
        
        Sxhpai
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/favicon.png">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/favicon.png","favicon":"/images/favicon.png","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":true,"scale":true},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":true}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 6.1.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Sxhpai
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">第六章——函数</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/favicon.png">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">sxhpai</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-05-24 16:24:05</span>
        <span class="mobile">2022-05-24 16:24</span>
    </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/C-Primer/">C++ Primer</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h3 id="第六章——函数"><a href="#第六章——函数" class="headerlink" title="第六章——函数"></a>第六章——函数</h3><blockquote>
<p>函数是一个命名了的代码块，我们通过调用函数执行相应的代码。</p>
</blockquote>
<h4 id="1-函数基础"><a href="#1-函数基础" class="headerlink" title="1. 函数基础"></a>1. 函数基础</h4><ul>
<li><p>调用函数时，即使某个形参不被函数使用，也必须为它提供一个实参。</p>
</li>
<li><p>函数的声明，因为函数的声明不包含函数体，所以也就无须形参的名字。事实上，在函数的声明中经常省略形参的名字。函数声明也称作<strong>函数原型</strong>。</p>
</li>
<li><p>函数的三要素（<strong>返回类型、函数名、形参类型</strong>）描述了函数的接口，说明了调用该函数的全部信息。</p>
</li>
<li><p>建议变量在头文件中声明，在源文件中定义。与之类似，函数也应该在头文件中声明而在源文件中定义。</p>
<ul>
<li>声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义负责创建与名字关联的实体。</li>
<li>变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。</li>
</ul>
</li>
<li><p>含有函数声明的头文件应该被包含到定义函数的源文件中。</p>
</li>
</ul>
<blockquote>
<p><code>Chapter.h</code>         头文件用于存放函数声明。</p>
<p><code>fact.cpp</code>           用于存放要使用的函数。</p>
<p><code>factMain.cpp</code>   用于存放主函数，执行相应的功能。</p>
<p>用以下指令进行分离式<strong>编译</strong>并<strong>执行</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第一步： 编译</span></span><br><span class="line">g++ fact.cpp factMain.cpp -o factMain</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">第二步： 执行</span></span><br><span class="line">./factMain</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2. 参数传递"></a>2. 参数传递</h4><h5 id="const形参与实参"><a href="#const形参与实参" class="headerlink" title="const形参与实参"></a>const形参与实参</h5><ul>
<li>和其他变量一样，形参的类型决定了形参和实参的交互的方式。如果形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。</li>
<li>熟悉C的程序员常常使用指针类型的形参访问函数外部的对象。在C++语言中<strong>，建议使用引用类型的形参替代指针。</strong></li>
<li>使用引用避免拷贝，拷贝大地类类型对象比较低效(典型的就是：string 类型，应使用引用以避免拷贝)，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</li>
<li>当函数需要多个返回值时，通过传<strong>引用形参的方式解决</strong>。</li>
<li><font color="[#1E90FF]">C++ 允许我们用字面值初始化常量引用。</font></li>
<li>尽量使用常量引用。把函数不会改变的形参定义成常量应该成为一种习惯。否则会有意想不到的后果。</li>
</ul>
<h5 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h5><ul>
<li><p>数组有两个特殊的性质，不允许拷贝数组以及使用数组时会将其转换成指针。</p>
</li>
<li><p>管理指针形参的三种常用技术：</p>
<ol>
<li>使用标记指定数组长度</li>
<li>使用标准库规范，传递指向数组首元素和尾后元素的指针。</li>
<li>显式传递一个表示数组大小的形参，重写一个表示数组大小的形参。</li>
</ol>
</li>
<li><p>数组引用形参</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : arr) &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> k[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// print(&amp;i);      //错误：实参不是含有10个整数的数组</span></span><br><span class="line">    <span class="comment">// print(j);       // 错误：实参不是含有10个整数的数组</span></span><br><span class="line">    <span class="built_in">print</span>(k);       <span class="comment">// 正确：实参是含有10个整数的数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>传递多维数组，在C++语言中实际上没有真正的多维数组，所谓多维数组其实是数组的数组。</p>
<p>多维数组，数组第二维（以及后面所有维度）的大小都是数组类型的一部分，不能省略。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*matrix) [<span class="number">4</span>], <span class="type">int</span> rowSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != rowSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> elem : *(matrix + i)) &#123;</span><br><span class="line">            cout &lt;&lt; elem &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">print</span>(matrix,<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="main-处理命令行选项"><a href="#main-处理命令行选项" class="headerlink" title="main: 处理命令行选项"></a>main: 处理命令行选项</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 argc *argv[] 的功能</span></span><br><span class="line"><span class="comment">// 将 test_6.exe </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != argc; ++i) &#123;</span><br><span class="line">        cout &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a>含有可变形参的函数</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++beg) &#123;</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-返回类型和-return-语句"><a href="#3-返回类型和-return-语句" class="headerlink" title="3. 返回类型和 return 语句"></a>3. 返回类型和 return 语句</h4><ul>
<li><code>return</code>语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。</li>
</ul>
<h5 id="无返回值函数"><a href="#无返回值函数" class="headerlink" title="无返回值函数"></a>无返回值函数</h5><ul>
<li>没有返回值的 return 语句只能用在返回类型是 void 的函数中。</li>
<li>返回 void 的函数不要求非得有 return 语句，因为在这类函数的最后一句后面会隐式执行 return 。</li>
</ul>
<h5 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h5><ul>
<li><font color="[#1E90FF]">在含有 return 语句的循环后面应该也有一条 return 语句，如果没有的话该程序应该就是错误的。很多编译器都无法发现此类错误。</font>
</li>
<li><blockquote>
<p>值是如何被返回的，返回一个值的方式和初始化一个变量或形参的方式完全一样<strong>：返回的值用于初始化调用点的一个临时量</strong>，该临时量就是函数调用的结果。</p>
<font color="#1E90FF">当对象在创建时获得了一个特定的值，我们说这个对象被**初始化**了。初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</font>
</blockquote>
</li>
<li><p>要想确定返回值安全，我们不妨提问：<strong>引用所引的是在函数之前已经存在的哪个对象</strong>？</p>
</li>
<li><p>引用返回左值，调用一个返回引用的函数得到左值，其他返回类型得到右值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">get_val</span><span class="params">(string &amp;str, string::size_type ix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str[ix];     <span class="comment">// get_val 假定索引值是有效的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;      <span class="comment">// 输出 a value</span></span><br><span class="line">    <span class="built_in">get_val</span>(s, <span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;    <span class="comment">// 将 s[0] 的值改为 A</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;      <span class="comment">// 输出 A value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回类型是常量引用，我们不能给调用的结果赋值，这一点和我们熟悉的情况是一样的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 列表初始化返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( a == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;sun&quot;</span>, <span class="string">&quot;xing&quot;</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;sun&quot;</span>, <span class="string">&quot;xing&quot;</span>, <span class="string">&quot;hui&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">process_0</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( a == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">auto</span> c : <span class="built_in">process_0</span>(<span class="number">-1</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>主函数 main 的返回值，我们允许 mian 函数没有 return 语句直接结束。如果控制到达了 main函数的结尾处而且没有 return 语句，编译器将隐式地插入一条返回 0 地 return 语句。</p>
</li>
<li><p>main 函数的返回值可以看做是状态指示器。返回 0 表示执行成功，返回其他值表示执行失败，其中非 0 值的具体含义依机器而定。</p>
</li>
</ul>
<p>虽然从语法上来说，要定义一个返回数组的指针或引用的函数比较烦琐，但是有一些方法可以简化这一任务，其中最直接的方法是使用类型别名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组类型别名</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>];      <span class="comment">// arrT是一个类型别名，它表示的类型是含有10个整数的数组。</span></span><br><span class="line"> <span class="keyword">using</span> arrT = <span class="type">int</span>[<span class="number">10</span>];      <span class="comment">// arrT 等价声明。</span></span><br><span class="line"> <span class="function">arrT* <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span>;         <span class="comment">// func 返回一个指向含有 10 个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的维度应跟随在要定义的数组之后</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];		<span class="comment">// arr 是一个含有10个整数的数组</span></span><br><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>];		<span class="comment">// p1 是一个含有10个指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">10</span>];		<span class="comment">// p2 是一个指向含10个整数数组的指针，它是一个指针，指向含有10个整数的数组。</span></span><br></pre></td></tr></table></figure>
<p>如下所示为返回数组指针且不用别名的写法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span>)) [<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p><strong>尾返回类型：</strong></p>
<ul>
<li>这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func 接受一个 int 类型的实参，返回一个指针，该指针指向含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>arrPtr 使用关键字 decltype 表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">// 返回一个指针，该指针向含有5个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i) &#123;		<span class="comment">// 这是一个函数的定义</span></span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd : &amp;even;  <span class="comment">// 返回一个指向数组的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-函数重载"><a href="#4-函数重载" class="headerlink" title="4. 函数重载"></a>4. 函数重载</h4><ul>
<li><p>不允许两个函数除了返回类型外其他所有的要素都相同。假设有两个函数，它们的形参列表一样但是返回类型不同，则第二个函数的声明是错误的；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lookup</span><span class="params">(<span class="type">const</span> string &amp;)</span></span>;	<span class="comment">// 错误: 与上一个函数相比只有返回类型不同 </span></span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p>最好只重载那些确实非常相似的操作。</p>
</blockquote>
</li>
<li><p>```cpp<br>// const_cast 和 重载</p>
<p>const string &amp; shorterString(const string &amp;s1, const string &amp;s2) {</p>
<pre><code>return s1.size() &lt;= s2.size() ? s1 : s2;
</code></pre><p>}</p>
<p>string &amp; shorterString(string &amp;s1, string &amp;s2) {</p>
<pre><code>auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1),const_cast&lt;const string&amp;&gt;(s2));
return const_cast&lt;string&amp;&gt;(r);
</code></pre><p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 现在我们需要掌握的是，当调用重载函数时有三种可能的结果：</span><br><span class="line">  </span><br><span class="line">  - 编译器找到一个与实参**最佳匹配**的函数，并生成调用该函数的代码。</span><br><span class="line">  </span><br><span class="line">  - 找不到任何一个函数与调用的实参匹配，此时编译器发出**无匹配**的错误信息。</span><br><span class="line"></span><br><span class="line">  - 有多于一个函数可以匹配，但是每一个都是明显的最佳选择。此时也将发生错误，称为**二义性调用**。</span><br><span class="line">  </span><br><span class="line">- 重载和作用域的关系：一般来说，将函数声明置于局部作用域内不是一个明智的选择。但是为了说明作用域和重载的相互关系，这里将暂时违反这一条原则而使用局部函数声明。</span><br><span class="line"></span><br><span class="line">  ```cpp</span><br><span class="line">  string read();</span><br><span class="line">  void print(const string &amp;);</span><br><span class="line">  void print(double);			// 重载函数</span><br><span class="line">  void fooBar(int ival) &#123;</span><br><span class="line">      bool read = false;		// 新作用域：隐藏了外层的read</span><br><span class="line">      string s = read();		// 错误：read是一个布尔值，而非函数</span><br><span class="line">      // 不好的习惯；通常来说，在局部作用域中声明函数不是一个好的选择</span><br><span class="line">      void print(int);		// 新作用域：隐藏了之前的print</span><br><span class="line">      print(&quot;Value: &quot;);		// 错误：print(const string &amp;) 被隐藏掉了</span><br><span class="line">      print(ival);			// 正确：当前 print(int) 可见</span><br><span class="line">      print(3.14);			// 正确：调用 print(int); print(double) 被隐藏掉了</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 C++ 语言中，名字查找发生在类型检查之前。</p>
</li>
</ul>
<h4 id="5-特殊用途语言特性"><a href="#5-特殊用途语言特性" class="headerlink" title="5. 特殊用途语言特性"></a>5. 特殊用途语言特性</h4><h5 id="5-1-默认实参"><a href="#5-1-默认实参" class="headerlink" title="5.1 默认实参"></a>5.1 默认实参</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;	</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="type">char</span> backgrnd = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以为一个或多个形参定义默认值，不过需要注意的是，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</li>
<li>当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面。</li>
<li>通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</li>
</ul>
<h5 id="5-2-内联函数和constexpr函数"><a href="#5-2-内联函数和constexpr函数" class="headerlink" title="5.2 内联函数和constexpr函数"></a>5.2 内联函数和constexpr函数</h5><ul>
<li>内联函数可避免函数调用的开销。将函数指定为内联函数，通常就是将它在每个调用点上“内联展开”。</li>
</ul>
<blockquote>
<p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p>
</blockquote>
<ul>
<li>内联机制用于优化规模较小、流程直接、频繁调用的函数。</li>
</ul>
<blockquote>
<p><strong>常量表达式</strong>是指不会改变并且在编译过程就能得到计算结果的表达式。显然，字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式。</p>
<p>constexpr函数是指能用于常量表达式的函数，但是，<strong>constexpr函数不一定返回常量表达式</strong>。</p>
</blockquote>
<ul>
<li>把内联函数和 constexpr 函数放在头文件内。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较两个 string 对象的长度，内联型</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>调试帮助</p>
<ul>
<li><code>assert</code>是一种预处理宏。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无须提供<code>using</code>声明。</li>
</ul>
<blockquote>
<p><code>assert</code>宏常用于检查“不能发”的条件。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。此时，程序可以包含一条如下所示的语句，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert</span>(word.<span class="built_in">size</span>() &gt; threshold);</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>assert 的行为依赖于一个名为 NDEBUG 的预处理变量的状态。如果定义了 NDEBUG，则 assert 什么也不做。默认状态下没有定义 NDEBUG，此时 assert 将执行运行时检查。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Vector 对象能高效增长。开始的时候创建空的 vector 对象，在运行时再动态添加元素，这一做法与 C 语言及其他大多数语言中的内置数组类型的用法不同。特别是如果用习惯了 C 或者 Java，可以预见再创建 vector 对象时顺便指定其容量是最好的。然而事实上，通常的情况是恰恰相反。</p>
</blockquote>
<ul>
<li>可以使用 NDEBUG 编写自己的条件调试代码。如果 NDEBUG 未定义，将执行 #ifndef  和 #endif 之间的代码；如果定义了 NDEBUG，这些代码将被忽略掉。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NDEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> threshold = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> string word)</span> </span>&#123;   </span><br><span class="line">    <span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">        <span class="keyword">if</span> (word.<span class="built_in">size</span>() &lt; threshold) &#123;</span><br><span class="line">        <span class="comment">//  _ _func_ _ 是编译器定义的一个局部静态变量，用于存放函数的名字</span></span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot; Error: &quot;</span> &lt;&lt; __FILE__</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; : in function &quot;</span> &lt;&lt; __func__</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; at line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; endl</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;      Compiled on &quot;</span> &lt;&lt; __DATE__</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; at &quot;</span> &lt;&lt; __TIME__ &lt;&lt; endl</span><br><span class="line">                  &lt;&lt; <span class="string">&quot;      Word rea was \&quot; &quot;</span> &lt;&lt; word</span><br><span class="line">                  &lt;&lt; <span class="string">&quot; \&quot;: Length too short &quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hui&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-函数匹配"><a href="#6-函数匹配" class="headerlink" title="6. 函数匹配"></a>6. 函数匹配</h4><ul>
<li><p>寻找最佳匹配：它的基本思想是：实参类型与形参类型越接近，它们匹配得越好。</p>
</li>
<li><p>调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。</p>
</li>
<li><p>实参类型转换</p>
<ol>
<li>精确匹配，包括以下情况：<ul>
<li>实参类型和形参类型相同。</li>
<li>实参从数组类型或函数类型转换成对应的指针类型。</li>
<li>向实参添加顶层 const 或者从实参中删除顶层 const。</li>
</ul>
</li>
<li>通过 const 转换实现的匹配。</li>
<li>通过类型提升实现的匹配。</li>
<li>通过<strong>算术类型转换</strong>或<strong>指针转换</strong>实现的匹配。</li>
<li>通过类类型转换实现的匹配。</li>
</ol>
<ul>
<li><p><strong>所有算术类型的转换的级别都一样</strong>。</p>
</li>
<li><blockquote>
<p>内置类型的提升和转换可能在函数匹配时产生意想不到的结果，但幸运的是，在设计良好的系统种函数很少会含有与下面例子类似的形参。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>函数匹配和 const 实参</p>
</li>
</ul>
<h4 id="7-函数指针"><a href="#7-函数指针" class="headerlink" title="7. 函数指针"></a>7. 函数指针</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较两个 string 对象的长度</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pf 指向一个函，该函数的参数是两个 const string 的引用，返回值是 bool 类型</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;);		<span class="comment">// 未初始化</span></span><br></pre></td></tr></table></figure>
<p>当我们能把函数名作为一个值使用时，该函数自动地转换成指针。</p>
<ul>
<li><p>重载函数的指针</p>
</li>
<li><p>函数指针形参</p>
</li>
<li>返回指向函数的指针</li>
<li>将 auto 和 decltype 用于函数指针类型</li>
</ul>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：第六章——函数</li>
        <li>本文作者：sxhpai</li>
        <li>创建时间：2022-05-24 16:24:05</li>
        <li>
            本文链接：https://sxhpai.github.io/2022/05/24/Primer6/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/C-Primer/">#C++ Primer</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2022/06/02/note2/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">底层const 与 顶层const</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2022/05/16/Primer5/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">第五章——语句</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">sxhpai</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0"><span class="nav-text">第六章——函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="nav-text">1. 函数基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-text">2. 参数传递</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#const%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82"><span class="nav-text">const形参与实参</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%BD%A2%E5%8F%82"><span class="nav-text">数组形参</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#main-%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="nav-text">main: 处理命令行选项</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%AB%E6%9C%89%E5%8F%AF%E5%8F%98%E5%BD%A2%E5%8F%82%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">含有可变形参的函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%92%8C-return-%E8%AF%AD%E5%8F%A5"><span class="nav-text">3. 返回类型和 return 语句</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%87%BD%E6%95%B0"><span class="nav-text">无返回值函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">有返回值的函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-text">4. 函数重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E7%89%B9%E6%AE%8A%E7%94%A8%E9%80%94%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="nav-text">5. 特殊用途语言特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="nav-text">5.1 默认实参</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8Cconstexpr%E5%87%BD%E6%95%B0"><span class="nav-text">5.2 内联函数和constexpr函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%87%BD%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="nav-text">6. 函数匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-text">7. 函数指针</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>




<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
